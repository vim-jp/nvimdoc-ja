*job_control.txt*    Nvim 0.12        Last change: 2025-08-24


                NVIMリファレンスマニュアル    by Thiago de Arruda


Nvim ジョブ制御			  			*job* *job-control*

ジョブ制御は Nvim でマルチタスクを実現する方法であり、スクリプトが現在の Nvim
インスタンスをブロックすることなく複数のプロセスを生成して制御できます。

                                            目次を確認するには |gO| をタイプ。

==============================================================================
コンセプト

ジョブ ID     						*job-id*

各ジョブは整数の ID で識別され、現在の Nvim セッションの間は一意です。各ジョブ
ID は有効な |channel-id| であり、同じ "キー空間" を共有します。 |jobstart()|のよう
な関数はジョブ ID を返します。 |jobstop()|、 |chansend()|、 |rpcnotify()|や
|rpcrequest()| などの関数はジョブ ID を受け取ります。

ジョブの標準入出力ストリームは、生のバイトや |msgpack-rpc| メッセージを送受信
できる |channel| を形成します。

==============================================================================
使い方							*job-control-usage*

ジョブを制御するには、"job…" ファミリーの関数を使用します。例えば:
|jobstart()|、 |jobstop()| 等。

例: >vim


    function! s:OnEvent(job_id, data, event) dict
      if a:event == 'stdout'
        let str = self.shell.' stdout: '.join(a:data)
      elseif a:event == 'stderr'
        let str = self.shell.' stderr: '.join(a:data)
      else
        let str = self.shell.' exited'
      endif

      call append(line('$'), str)
    endfunction
    let s:callbacks = {
    \ 'on_stdout': function('s:OnEvent'),
    \ 'on_stderr': function('s:OnEvent'),
    \ 'on_exit': function('s:OnEvent')
    \ }
    let job1 = jobstart(['bash'], extend({'shell': 'shell 1'}, s:callbacks))
    let job2 = jobstart(['bash', '-c', 'for i in {1..10}; do echo hello $i!; sleep 1; done'], extend({'shell': 'shell 2'}, s:callbacks))

上記のスクリプトを試すには、~/foo.vim にコピーした後、次のコードを実行します:
>bash
    nvim -u ~/foo.vim
<
挙動の解説:
  - |jobstart()| 関数によって、標準ストリームが nvim に接続された二つの bash
    シェルを生成する。
  - 最初のシェルはアイドル状態であり、標準入力からコマンドを読み込むために待機
    する。
  - もう一つのシェルは -c オプションで開始しており、コマンド(0から9までを表示
    する for ループ)を実行した後、終了する。
  - 様々なジョブイベントを処理するために `OnEvent()` コールバックが |jobstart()|に
    渡される。これはシェルから受け取った標準出力や標準エラー出力を表示する。

|on_stdout| と |on_stderr| については |channel-callback| を参照。
							*on_exit*
on_exit コールバックに渡される引数:
  0: |job-id|
  1: プロセスの終了ステータス、またはシグナルによる場合は 128+SIGNUM (例:
     SIGTERM の場合は 143)。
  2: イベントタイプ: "exit"


  Note: 送信側によってフラッシュされていないバッファリングされた標準出力及びエ
        ラー出力は on_stdout 及び on_stderr コールバックをトリガーしません(た
        だし、プロセスが終了した場合、on_exit コールバックが呼ばれます)。
        例えば、"ruby -e" は出力をバッファリングするため、「自動フラッシュ」
        ($stdout.sync=true)が有効になっていない限り、短い文字列はバッファリン
        グされます。 >vim
          function! Receive(job_id, data, event)
            echom printf('%s: %s',a:event,string(a:data))
          endfunction
          call jobstart(['ruby', '-e',
            \ '$stdout.sync = true; 5.times do sleep 1 and puts "Hello Ruby!" end'],
            \ {'on_stdout': 'Receive'})
<       https://github.com/neovim/neovim/issues/1592

  Note 2:
	ジョブイベントハンドラは、部分的な(不完全な)行を受け取る場合がありま
	す。on_stdout 及び on_stderr の特定の呼び出しにおいて、 `a:data` が改
	行で終わるかは保証されません。
	  - `abcdefg` は `['abc']`、 `['defg']` として受け取る可能性があります。
	  - `abc\nefg` は `['abc', '']`、 `['efg']` や `['abc']`、 `['','efg']` 更には
            `['ab']`、 `['c','efg']` として受け取る可能性があります。
	最も簡単な対処法は、リストを `['']` として初期化し、次の様に追加するこ
	とです: >vim
	  let s:chunks = ['']
	  func! s:on_stdout(job_id, data, event) dict
	    let s:chunks[-1] .= a:data[0]
	    call extend(s:chunks, a:data[1:])
	  endf
<

|jobstart-options| 辞書は |self| としてコールバックに渡されます。
上記の例は次のように「オブジェクト指向」な形で記述できます: >vim

    let Shell = {}

    function Shell.on_stdout(_job_id, data, event)
      call append(line('$'),
            \ printf('[%s] %s: %s', a:event, self.name, join(a:data[:-2])))
    endfunction

    let Shell.on_stderr = function(Shell.on_stdout)

    function Shell.on_exit(job_id, _data, event)
      let msg = printf('job %d ("%s") finished', a:job_id, self.name)
      call append(line('$'), printf('[%s] BOOM!', a:event))
      call append(line('$'), printf('[%s] %s!', a:event, msg))
    endfunction

    function Shell.new(name, cmd)
      let object = extend(copy(g:Shell), {'name': a:name})
      let object.cmd = ['sh', '-c', a:cmd]
      let object.id = jobstart(object.cmd, object)
      $
      return object
    endfunction

    let instance = Shell.new('bomb',
          \ 'for i in $(seq 9 -1 1); do echo $i 1>&$((i % 2 + 1)); sleep 1; done')
<
ジョブの標準入力にデータを送るには、 |chansend()| を使用します: >vim
    :call chansend(job1, "ls\n")
    :call chansend(job1, "invalid-command\n")
    :call chansend(job1, "exit\n")
<
ジョブは |jobstop()| によっていつでも強制終了できます:
>vim
    :call jobstop(job1)
<
ジョブを強制終了せずに各ストリームを閉じることも可能です。 |chanclose()| を参照
してください。

 vim:tw=78:ts=8:noet:ft=help:norl:
