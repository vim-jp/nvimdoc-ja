*intro.txt*     Nvim 0.12        Last change: 2025-08-24


                         NVIMリファレンスマニュアル


Nvim                                                    *ref* *reference*

                                            目次を確認するには |gO| をタイプ。

==============================================================================
はじめに						*intro*

Vim はテキストエディタです。Unix のプログラム "Vi" のほとんどのコマンドと、さ
らに多くの新しいコマンドを備えています。

このマニュアルの概要は |help.txt| にあります。Vim から <Help> や <F1> キー、
|:help| コマンドで開くことができます (単に :help と入力してください。引用符も
バーも必要ありません)。
ヘルプファイルが標準の位置にインストールされていない場合は、ヘルプファイルの名
前をオプション 'helpfile' に設定してください。タグでジャンプするのと同じように
ヘルプの項目へジャンプできます。ジャンプしたい項目にカーソルを合わせて CTRL-]
でジャンプできます。 CTRL-T で元の場所に戻れます。

                                                        *pronounce*
Vim は Jim のように一語として発音します。なので、Nvim は 二音節で "En-Vim" と
発音します。

このマニュアルは全ての Nvim エディタと API 機能のリファレンスです。入門書では
ありません。初心者は、実習 |tutor| や |lua-guide|、 |user-manual| をご覧ください。

------------------------------------------------------------------------------
リソース                                                *resources*

                                                *internet* *www* *distribution*
Nvim の公式サイトはこちら:

        https://neovim.io/

                                                *book*
Vi や Vim、Nvim を学ぶためのたくさんの資料が存在します。こちらがおすすめです:

- Drew Neil 著 "Practical Vim"。Vim における一般的な編集タスクを素早く習得する
  ことに重視した本であり、高い評価を受けています。
  {訳注: 邦題: 実践Vim 思考のスピードで編集しよう!}
- Drew Neil 著 "Modern Vim"。Nvim と Vim 8 の新機能について解説しています。
- https://vimcasts.org/publications/
- Steve Oualline 著 "Vim - Vi Improved"。これは Vim を題材にした初めての本で
  す。本書の一部は Vim ユーザーマニュアルに含まれています: |frombook|
  {訳注: 邦題: Vi IMproved-Vim完全バイブル}
- こちらからも更なる情報を得ることができます:
  - https://iccf-holland.org/click5.html
  - https://www.vim.org/iccf/click5.html
- Vim FAQ: https://vimhelp.org/vim_faq.txt.html

                                                *bugs* *bug-report* *feature-request*
バグ報告や新機能のリクエストはこちら: https://github.com/neovim/neovim/issues
メッセージは簡潔かつ完全なものにしてください。常に再現可能な例をつけてくださ
い。そして、バグを引き起こす設定やその他のものを探してください。もし Nvim がク
ラッシュした場合、バックトレースを試してください。(|dev-tools-backtrace| を参照)

==============================================================================
Nvim のインストール                                     *install*

                                                *download* *upgrade* *ubuntu*
Nvim をインストールするにはいくつかの方法があります...
- ビルド済みのアーカイブをダウンロードする:
  https://github.com/neovim/neovim/releases
- お使いのシステムのパッケージマネージャーを利用する:
  https://github.com/neovim/neovim/blob/master/INSTALL.md#install-from-package
- ソースからビルドする:
  https://github.com/neovim/neovim/blob/master/INSTALL.md#install-from-source

------------------------------------------------------------------------------
Nvim のアンインストール                                 *uninstall*

Nvim をアンインストールするには:
- ビルド済みアーカイブやソースからビルドした場合(例: `make install`)、ファイル
  を直接削除してください。主に次の場所に存在します: >
  /usr/local/bin/nvim
  /usr/local/share/nvim
<
  - Nvim のインストール先を見つけるには、以下のコマンドを実行します: >
    :echo v:progpath
    :echo $VIMRUNTIME
<
- パッケージマネージャーからインストールした場合、それらのドキュメントを参照し
  てください。主要なものはこちら:
  - APT (Debian, Ubuntu, …): `apt-get remove neovim`
  - Homebrew (macOS): `brew uninstall neovim`
  - Scoop (Windows): `scoop uninstall neovim`

==============================================================================
Vim や Nvim の開発を支援する                            *sponsor*

バグ修正や新機能の追加には多くの時間と労力がかかります。感謝の意を表明し、Vim
の開発を続ける開発者たちを励ますために、ぜひ寄付をお願いします。

寄付金は主にウガンダの子どもたちへの支援のために使われます。詳しくは |uganda|を
ご覧ください。寄付は同時に、開発チームが Vim の開発を継続するためのモチベーショ
ンを高めてくれます!
スポンサーに関する最新情報は Vim のWebサイトをご確認ください。

        https://www.vim.org/sponsor/


Nvim の開発は Vim とは別途の資金提供によって成り立っています:

        https://neovim.io/#sponsor

==============================================================================
Bram Moolenaar                  *Bram* *Moolenaar* *Bram-Moolenaar* *brammool*

Nvim は Bram Moolenaar によって開発された Vim ("Vi IMproved") のフォークです。
Nvim のソースコードの中で彼の名前を検索すると、彼の功績の多くが Nvim の中に残っ
ているか確認できます。
2023年8月3日、彼は62歳で亡くなりました。Vim や Nvim があなたの人生で役に立った
のであれば、是非 |Uganda| を読んで、彼の思い出を偲んでください。

- 訃報: https://github.com/vim/vim/discussions/12742
- 別れを告ぐ: https://github.com/vim/vim/discussions/12737

==============================================================================
4. ヘルプの表記法					*notation*

この文章を構文強調を使って表示すると、見たままの意味ではないテキストは特別に強
調表示されます。[]、{}、<>、で囲まれた項目や CTRL-X などです。

Note: Vim は入力可能な文字はすべてコマンドで使います。実際に、[]、{}、<> を入
力する場合もあります。それは文脈によって判断できるでしょう。


[]		角カッコで囲まれた文字は省略可能。

						    *count* *[count]*
[count]		コマンドに前置して、そのコマンドを繰り返したり、反復したりする
		ための省略可能な数字。省略した場合、特に注意が無ければ 1 を指
		定したのと同じになります。Note: このマニュアルでは、[count] は
		コマンドの説明では言及されません。解説する場合だけ説明します。
                これはコマンドを調べ易くするためです。 'showcmd' オプションが
                有効だと、(部分的に) 入力されたカウントがウィンドウの下の方に
                表示されます。<Del> を使って末尾の数字を削除できます(|N<Del>|)。

							*[quotex]*
["x]		テキストの保管場所として、任意のレジスタを指定できることを示す。
		|registers| を参照。x は 'a' から 'z'、'A' から 'Z'、'"'、のど
		れか一文字です。場合によっては (put コマンドで使うときなど)、
		'0' から '9'、'%'、'#'、その他の文字も使えます。大文字でも小文
		字でも同じレジスタを指しますが、小文字を使ったときはレジスタの
		内容が上書きされ、大文字を使ったときはレジスタの内容に追加され
		ます。"x を指定しなかった場合や、"" を指定した場合は、無名レジ
		スタが使われます。

							*{}*
{}		中括弧の表記は、コマンドの一部として入力する必要があって、そこ
		には、いろいろな値を入力することができるときに使われます。Vim
		と Vi の違いを示す場合も中括弧で表記されます (これは文脈から区
		別できます)。

							*{char1-char2}*
{char1-char2}	char1 から char2 の範囲のどれか一文字。例えば、{a-z} は小文字
		一文字。複数の範囲が指定される場合もあります。例えば、
		{a-zA-Z0-9} は英数字のどれか一文字です。

						*{motion}* *movement*
{motion}	カーソル移動コマンド。これらは、 |motion.txt| で説明されていま
		す。例:
			w		次の単語の最初に移動
			b		現在の単語の最初へ
			4j		4行下に移動
			/The<CR>	つぎの "The" が、ある場所に移動
		オペレータコマンド (|operator|) を入力した後で、対象のテキスト
		を選択するため使われます。
		- 移動コマンドがカウントを含み、オペレータコマンドもカウントを
		  含むときは、二つのカウントが掛け合わされる。例えば、"2d3w"
		  は 6 単語を削除する。
		- 移動はバックもできる。例えば、"db" は単語の最初までを削除す
		  る。
		- 移動はマウスのクリックでもできる。ただし、マウスをサポートし
		  ていない端末もあります。
		- ":omap" コマンドを使って、オペレータコマンドに対して移動コマ
		  ンドを入力しているときに働くマップを定義できます。
		- Ex コマンドを使ってカーソルを移動できます。関数を使って複雑
		  な移動をすることもできます。どの ":" コマンドが使われても、
		  移動は常に文字単位で排他的です。そのため、改行を含めずに行末
		  の文字を選択することはできません ('virtualedit' を設定すれば
		  可能)。
		  Ex コマンドで、オペレータコマンドを使った場所より前にあるテ
		  キストを変更したり、他のバッファに移動した場合、結果は予測で
		  きません。オペレータコマンドを使った場所以降のテキストなら変
		  更できます。カレントバッファがアンロードされないなら、他の
		  バッファにジャンプすることも可能です。

							*{Visual}*
{Visual}	選択されたテキストの範囲。"v"、"V"、 CTRL-V コマンドで選択を開
		始し、カーソル移動コマンドで選択範囲を変更できます。
		オペレータコマンド (|operator|) を実行する前に使って、対象のテ
		キストを選択することができます。 |Visual-mode| を参照。

							*<character>*
<character>	下記の表に示した特殊文字。修飾キーが付くこともあります。修飾
		キーと ASCII 文字の組合せもこのように表記されます。

							*'character'*
'c'		ASCII 文字 1 文字。

							*CTRL-{char}*
CTRL-{char}	制御文字として入力された文字 {char}。CTRL キーを押しながら
		{char} を押す場合です。{char} は大文字でも小文字でも区別されま
		せん。 CTRL-A と CTRL-a は同じです。SHIFT キーを使うと別のコー
		ド(CTRL-SHIFT-a 等)を生成する端末や環境もあるため、シフトキー
                は使わないでください。これらの環境では SHIFTキーは CTRL-A のよ
                うなコマンドをトリガーしません。

							*'option'*
'option'	オプション (設定) はシングルクォートで囲んで表記されます。オプ
		ションは設定値を変更できます。 |options| を参照。

							*quotecommandquote*
"command"	説明の中にでてくる入力可能なコマンドは、ダブルクォートで囲んで
		表記されます。
`command`	コマンドの新しい表記法です。他のクォート表記のテキストや文字列
		と区別するために使われます。

                                        *key-notation* *key-codes* *keycodes*
このドキュメントでは、キーの名前として以下のものが使われます。これらは ":map"
コマンドでも使うことができます。

表記		意味		      等価表現	10進数値	~
<Nul>		ゼロ			CTRL-@	  0 (10として保存) *<Nul>*
<BS>		バックスペース		CTRL-H	  8	*backspace*
<Tab>		タブ			CTRL-I	  9	*tab* *Tab*
							*linefeed*
<NL>		ラインフィード		CTRL-J	 10 (<Nul>に使用)
<CR>		キャリッジリターン	CTRL-M	 13	*carriage-return*
<Return>	<CR>と同じ				*<Return>*
<Enter>		<CR>と同じ				*<Enter>*
<Esc>		エスケープ		CTRL-[	 27	*escape* *<Esc>*
<Space>		スペース			 32	*space*
<lt>		小なり(less-than)	<	 60	*<lt>*
<Bslash>	バックスラッシュ	\	 92	*backslash* *<Bslash>*
<Bar>		垂直バー		|	124	*<Bar>*
<Del>		デリート			127
<CSI>		コマンドの開始バイト	ALT-Esc 155	*<CSI>*

<EOL>		行の終端 (<CR>、<NL>、<CR><NL> のどれかで、
		システムと 'fileformat' に依存)	*<EOL>*
<Ignore>        入力待機文字を無視                      *<Ignore>*
<NOP>           no-op: なにもしない (キーマップに有用)  *<Nop>*

<Up>		上カーソル			*cursor-up* *cursor_up*
<Down>		下カーソル			*cursor-down* *cursor_down*
<Left>		左カーソル			*cursor-left* *cursor_left*
<Right>		右カーソル			*cursor-right* *cursor_right*
<S-Up>		シフト + 上カーソル
<S-Down>	シフト + 下カーソル
<S-Left>	シフト + 左カーソル
<S-Right>	シフト + 右カーソル
<C-Left>	コントロール + 上カーソル
<C-Right>	コントロール + 上カーソル
<F1> - <F12>	ファンクションキー1から12	*function_key* *function-key*
<S-F1> - <S-F12> シフト + ファンクションキー1から12 *<S-F1>*
<Help>		ヘルプキー
<Undo>		アンドゥキー
<Find>          Find キー
<Select>        Select キー
<Insert>	挿入キー
<Home>		ホーム				*home*
<End>		エンド				*end*
<PageUp>	ページアップ			*page_up* *page-up*
<PageDown>	ページダウン			*page_down* *page-down*
<kUp>           テンキーの上カーソル            *keypad-cursor-up*
<kDown>         テンキーの下カーソル            *keypad-cursor-down*
<kLeft>         テンキーの左カーソル            *keypad-cursor-left*
<kRight>        テンキーの右カーソル            *keypad-cursor-right*
<kHome>		テンキーのホーム(左上)		*keypad-home*
<kEnd>		テンキーのエンド(左下)		*keypad-end*
<kOrigin>       テンキーの origin (中央)        *keypad-origin*
<kPageUp>	テンキーのページアップ(右上)	*keypad-page-up*
<kPageDown>	テンキーのページダウン(右下)	*keypad-page-down*
<kDel>          テンキーの削除キー              *keypad-delete*
<kPlus>		テンキーの+			*keypad-plus*
<kMinus>	テンキーの-			*keypad-minus*
<kMultiply>	テンキーの *			*keypad-multiply*
<kDivide>	テンキーの /			*keypad-divide*
<kPoint>        テンキーの .                    *keypad-point*
<kComma>        テンキーの ,                    *keypad-comma*
<kEqual>        テンキーの =                    *keypad-equal*
<kEnter>	テンキーのEnter			*keypad-enter*
<k0> - <k9>	テンキーの0から9		*keypad-0* *keypad-9*
<S-…>		シフトキー			*shift* *<S-*
<C-…>		コントロールキー		*control* *ctrl* *<C-*
<M-…>		altまたはmetaキー		*meta* *alt* *<M-*
<A-…>		<M-...>と同じ			*<A-*
<T-…>           altでないときのmetaキー         *<T-*
<D-…>		コマンドキー (Mac) / super (GTK)  *<D-*


Note:

- 一部のキー(<Help、 <S-Right> など) の使用可否は UI やホスト端末に依存します。
- Numlock がオンになっている場合、 |TUI| は素の ASCII 信号を受け取るため、
  <k0>、 <k1> ~ <k9> および <kPoint> のマッピングは機能しません。
- Nvim は `<M-ä>` のような修飾子を用いるマルチバイト文字のマッピングをサポート
  しています。どの組み合わせが機能するかは、UI または ホスト端末に依存します。
- metaキーやaltキーを使用してキーが押され、それに対するマッピングが存在しない
  場合、Nvim はそのキーの前に <Esc> が押されたかのように振る舞うことがありま
  す。
- 複合修飾子(例: <M-C-T>、つまり CTRL-ALT-T)を表記することも可能です。ただし、
  端末側で入力をエンコードする必要があります。

                                                                *<>*
例ではよく <> 表記が使われます。これは、何を入力すべきかを明確に表記するために
使われますが、文字どおりに入力する必要がある場合もあります。例えば、":map" コ
マンドで使う場合など。規則は以下のとおりです:
1.  バックスラッシュと "<" 以外の印字可能文字はそのまま表記される。
2.  バックスラッシュは "\\" (ダブルバックスラッシュ)、または "<Bslash>" と表記
    される。
3.  実際の "<" は "\<"、または "<lt>" と表記される。混乱を招く恐れがなければ、
    "<" はそのまま使われる。
4.  "<key>" means the special key typed (see the table above).  Examples:
4.  "<key>" は特殊キーを打つことを示す(上記の表を参照)。いくつか例を挙げます:
	   <Esc>		エスケープキー
	   <C-G>		CTRL-G
	   <Up>			上カーソルキー
	   <C-LeftMouse>	コントロール + 左マウスクリック
	   <S-F11>		シフト + ファンクションキー11
	   <M-a>		Meta + a  ('a' with bit 8 set)
	   <M-A>		Meta + A  ('A' with bit 8 set)

<> 表記の特別な意味をなくすには <lt> を使います。バックスラッシュを使う方法も
機能しますが、それは 'cpoptions' が 'B' フラグを含んでいないときだけです。

CTRL-H を "<Home>" の 6 文字にマップする例: >vim
        :imap <C-H> \<Home>
        :imap <C-H> <lt>Home>
最初の例は 'cpoptions' に 'B' フラグが含まれていない場合のみ機能します。2 番目
の例は常に機能します。
マップで "<lt>" を文字どおりに使うには 次のようにします: >vim
        :map <C-L> <lt>lt>

この表記は、ダブルクォートで囲んだ文字列の先頭に "\<" を付けて使用することがで
きます。例えば "\<C-Space>"。この結果、特殊なキーコードが生成されます。これを
読みやすいテキストに戻す変換には、 `keytrans()` を使用します。

==============================================================================
モードの紹介					*vim-modes-intro* *vim-modes*

Vim has seven BASIC modes:

                                        *Normal* *Normal-mode* *command-mode*
- ノーマルモード	ノーマルモードでは普通の編集コマンドを全て入力できま
                        す。エディタをスタートするとこのモードに入ります 。こ
                        れはコマンドモードとも呼ばれます。

- ビジュアルモード	ノーマルモードに似ていますが、移動コマンドで選択領域が
			拡大されます。移動コマンド以外のコマンドを使うと、選択
			領域に対してそのコマンドが実行されます。 |Visual-mode|
			を参照。
			オプション 'showmode' がオンなら、"-- VISUAL --" が
			ウィンドウの最下部に表示されます。

- 選択モード		これは、MS-Windows でテキストを選択するときの動作に似
			ています。印字可能文字が入力されると、選択範囲を削除
			し、挿入モードに入ります。|Select-mode|を参照。
			オプション 'showmode' がオンなら、"-- SELECT --" が
			ウィンドウの最下部に表示されます。

- 挿入モード		挿入モードでは、タイプされたテキストはバッファに挿入
			されます。|Insert-mode|を参照。
			オプション 'showmode' がオンなら、"-- INSERT --" が
			ウィンドウの最下部に表示されます。

- コマンドラインモード	コマンドラインモードでは、ウィンドウの下部に 1 行のテ
			キストを入力できます。これは Ex コマンド、":"、パター
			ン検索コマンド、"?"、"/"、そしてフィルタコマンド、"!"
			で使用します。 |Cmdline-mode| を参照。

- Ex モード		コマンドラインモードに似てますが、コマンド入力後も Ex
			モードに留まります。コマンドライン編集は、かなり制限さ
			れます。 |Ex-mode| を参照。

                                                        *Terminal-mode*
- ターミナルモード      ターミナルモードでは、すべての入力 (CTRL-\ を除く)が現
                        在の |terminal| バッファで実行中のプロセスに送信されま
                        す。 CTRL-\ が押された場合は、その次のキーが送信されま
                        す。ただし、それが CTRL-N (|CTRL-\_CTRL-N|) または
                        CTRL-O (|t_CTRL-\_CTRL-O|) の場合を除く。オプション
                        'showmode' がオンなら、"-- TERMINAL --" がウィンドウの
                        最下部に表示されます。

加えて、6 つのモードがあります。これらは基本モードの変種です。

                                *Operator-pending* *Operator-pending-mode*
- オペレータ待機モード	ノーマルモードに似てますが、オペレータコマンドが実行さ
			れた後で、その適用範囲を決定するための移動コマンド
			({motion}) を得るために、Vim が待機している状態です。

- 置換モード		置換モードは挿入モードの特別版です。挿入モードと同様の
			ことができますが、一文字入力するごとに、その場所にある
			文字が一つ削除されます。 |Replace-mode| を参照。
			オプション 'showmode' がオンなら、"-- REPLACE --" が
			ウィンドウの最下部に表示されます。

- 仮想置換モード	仮想置換モードは置換モードに似ていますが、ファイルの文
			字の上ではなく、画面上の任意の位置を置換できます。
			|Virtual-Replace-mode| を参照。 'showmode' がオンなら、
			"-- VREPLACE --" がウィンドウの最下部に表示されます。

- 挿入ノーマルモード	挿入モードで CTRL-O を入力したときにこのモードに入りま
			す (|i_CTRL-O| を参照)。ノーマルモードに似ていますが、
			1つのコマンドを実行した後、Vimは挿入モードに戻ります。
			オプション 'showmode' がオンなら、"-- (insert) --" が
			ウィンドウの最下部に表示されます。

- 挿入ビジュアルモード	挿入モードでビジュアル選択を開始すると、このモードに入
			ります。例えば、 CTRL-O を使い, その後 "v"、"V"、
			CTRL-V を使ったときです。
			ビジュアル選択が終了すると、挿入モードに戻ります。
			オプション 'showmode' がオンなら、
			"-- (insert) VISUAL --" がウィンドウの最下部に表示され
			ます。

- 挿入選択モード	挿入モードで選択モードを開始すると、このモードに入りま
			す。例えば、マウスをドラッグしたり、 <S-Right> を押し
			たときです。
			選択モードが終了すると、挿入モードに戻ります。オプショ
			ン 'showmode' がオンなら、"-- (insert) SELECT --" が
			ウィンドウの最下部に表示されます。

==============================================================================
モードの切り替え					*mode-switching*

何らかの理由で、現在のモードがわからなくなったときは、 <Esc> を 2 度押すことで
常にノーマルモードに戻ることができます。Ex モードでは機能しないので、その場合
は ":visual" を使ってください。
<Esc> を押したとき、スクリーンフラッシュや、ベルの音で、ノーマルモードに戻った
ことを知ることができます。挿入モードで CTRL-O の後に <Esc> を押した場合、ビー
プ音は鳴りますが、まだ挿入モードの中なので、もう一度 <Esc> を押してください。

							*i_esc*
		移動先のモード					    ~
		Normal	Visual	Select	Insert	  Replace   Cmd-line  Ex ~
現在のモード								 ~
ノーマル		v V ^V	  *4	 *1	   R gR     : / ? !   Q
ビジュアル	 *2		  ^G	 c C	    --	      :       --
選択		 *5	^O ^G		 *6	    --	      --      --
挿入		 <Esc>	  --	  --		  <Insert>    --      --
置換		 <Esc>	  --	  --	<Insert>	      --      --
コマンドライン	 *3	  --	  --	 :start	    --		      --
Ex		 :vi	  --	  --	 --	    --	      --

-- 不可

- 1 ノーマルモードから挿入モードへは、コマンド "i"、"I"、"a"、"A"、"o"、"O"、
    "c"、"C"、"s"、"S" で入ります。
- 2 ビジュアルモードからノーマルモードへは非移動コマンドで入れますが、そのコマ
    ンドは実行されてしまいます。 <Esc>、"v"、"V"、"CTRL-V" (|v_v|を参照) を入力
    すれば、副作用なしにビジュアルモードから出られます。
- 3 コマンドラインモードからノーマルモードへ移行するには次のようにします:
    - <CR> か <NL> を入力する。入力途中のコマンドは実行されます。
    - 行の全てを削除し (例、 CTRL-U を使う)、そして、 <BS> を入力する。
    - CTRL-C または <Esc> を入力する、入力途中のコマンドを実行せずに終了できま
     す。
    最後の方法ですが、 <Esc> が 'wildchar' に設定されている場合があります。そ
    の場合、コマンドライン補完が実行されますが、それを無視して、再び <Esc> を
    入力してください。
- 4 ノーマルモードから選択モードに移行するには次のようにします:
    - 'selectmode' が "mouse" を含んでいるときは、マウスでテキストを選択する。
    - 'selectmode' が "key" を含んでいるときは、シフトキーを押しながら、特殊
      キーでカーソルを動かします。(:set keymodel+=startsel が必要)
    - 'selectmode' が "cmd" を含んでいるときは、"v"、"V"、"CTRL-V" を使う。
    - "gh"、"gH"、"g CTRL-H" を使う。 |g_CTRL-H|
- 5 選択モードからノーマルモードに移行するには、シフトキーを押さずに特殊キーで
    カーソルを動かします。(:set keymodel+=stopsel が必要)
- 6 選択モードから挿入モードへ移行するには、印字可能文字 (普通の文字) を入力し
    ます。選択範囲は削除され、入力した文字が挿入されます。

                        *CTRL-\_CTRL-N* *i_CTRL-\_CTRL-N* *c_CTRL-\_CTRL-N*
                                      *v_CTRL-\_CTRL-N* *t_CTRL-\_CTRL-N*
CTRL-\ CTRL-N と <C-\><C-N> を使って、どのモードからでもノーマルモードに移行で
きます。このコマンドを使えば、確実にノーマルモードになることができます。 <Esc>
のときのようにビープ音はなりません。ただし、Ex モードでは機能しません。 |f| や|m|
のように引数をとるコマンドの後で使われたときは、 'ttimeoutlen' で設定されたタ
イムアウトが適用されます。

        *CTRL-\_CTRL-G* *i_CTRL-\_CTRL-G* *c_CTRL-\_CTRL-G* *v_CTRL-\_CTRL-G*
CTRL-\ CTRL-G は、後方互換性のために、 |CTRL-\_CTRL-N| と同じ様に機能します。
                                *gQ* *mode-Ex* *Ex-mode* *Ex* *EX* *E501*
gQ			"Ex" モードに切り替えます。このモードは ":" コマンドを
			続けて入力するようなものですが、次の点が違います:
			- 毎回 ":" を押す必要がない。
			- コマンドを実行するごとに画面が更新されない。
			"Ex" モードを抜けるには、 `:vi` コマンド (|:visual|) を使
			います。

==============================================================================
ウィンドウに表示される内容				*window-contents*

ノーマルモードと挿入/置換モードでは、スクリーンに現在のバッファの内容が表示さ
れます。つまり、見ているものが得られるもの (WYSIWYG) です。しかし、例外が二つ
があります:
- オプション 'cpoptions' が '$' を含んでいて、一行に収まる範囲を変更 (|c|) す
  るときは、テキストはすぐに削除されず、削除される文字の最後の位置に '$' が表
  示されます。
- あるウィンドウでテキストを挿入していて、別のウィンドウでも同じテキストを表示
  しているとき、挿入を完了するまでそのウィンドウの表示は更新されません。
  {訳注: 確認できず}

ウィンドウの幅より長い行は、折り返して表示されます。'wrap' がオフのときは折り
返されません (下記参照)。'linebreak' を設定すると空白文字で折り返すことができ
ます。

ウィンドウ内でバッファの最終行より下に表示領域がある場合、以下のように、それら
の行の始めに '~' が表示されます:
>
	+-----------------------+
	|some line		|
	|last line		|
	|~			|
	|~			|
	+-----------------------+
<
このように、'~' はバッファの最後に到達したことを示します。

ウィンドウに表示されている最後の行が表示しきれない場合、以下のように、最終行の
場所に '@' が表示されます:
>
	+-----------------------+
	|first line		|
	|second line		|
	|@			|
	|@			|
	+-----------------------+
<
このように、'@' はウィンドウに収まりきらない行があることを示します。

'display' に "lastline" フラグが含まれている場合、'@' はウィンドウの左側に表示
されません。最終行がウィンドウに完全に収まらない場合は、収まる部分のみが表示さ
れ、最後の 3 文字が次のように "@@@" で置き換えられます:
>
	+-----------------------+
	|first line		|
	|second line		|
	|a very long line that d|
	|oesn't fit in the wi@@@|
	+-----------------------+
<
長すぎてウィンドウに収まりきらない単一の行があるときは、特別な場合として扱われ
ます。Vim はカーソルのある場所付近のみを表示します。特殊記号は表示されません。
その行のどの部分でも編集できます。

'@' と '~' の強調表示を設定するには、オプション ハイライトグループの
|hl-NonText| を設定します。それらの文字と、バッファの中の本物の文字を区別するこ
とができます。

折り返された行の先頭には 'showbreak' に設定した文字が表示されます。

                                                        *wrap-off*
'wrap' がオフの場合、長い行は折り返されません。スクリーンに収まる分だけ表示さ
れます。カーソルが表示されていない部分に移動すると、スクリーンは水平方向にスク
ロールします。この方法の利点は、縦の列がありのままに表示されること、スクリーン
に収まらない行も編集できることです。欠点としては、一行の全ての文字を一度に見る
ことができないことが挙げられます。'sidescroll' にはスクロールする最小の列(カラ
ム)数を設定します。

全ての普通のASCII文字はスクリーンに直接表示されます。<Tab> は、それが表現する
数のスペースに置き換えられます。他の非表示文字は、"^{char}" に置き換えられま
す、このとき {char} には、その非表示文字に 64 を足した文字が入ります。つまり、
文字 7 (ベル文字) は "^G" と表示されます。127 から 160 までの文字は "~{char}"
で置き換えられます、このとき {char} には、その文字から 64 を引いた文字が入りま
す。これらの文字はスクリーン上では複数幅で表示されます。カーソルはその複数幅の
先頭にのみ移動させることができます

'number' がオンの場合、全ての行の先頭に行番号が表示されます。
Tip: 行を折り返したときに、行番号と行の表示を混ぜたくないときは、'showbreak'
に 8 つのスペースをセットします: >
	":set showbreak=\ \ \ \ \ \ \ \ "

'list' がオンの場合、<Tab> 文字はいくつかのスペースとしてではなく、"^I" として
表示されます。'$' が行末に表示されるので、行の最後についた空白を見つけることが
できます。

コマンドラインモードでは、コマンドラインのみが正しく表示されます。バッファの
内容の表示は、コマンドラインモードから抜けたときに更新されます。

ウィンドウの最下行はステータスやその他のメッセージのために使われます。ステータ
スメッセージが使われるのは、オプションがオンのときのみです:

ステータスメッセージ		オプション     初期設定	 Unixの初期設定	~
現在のモード			'showmode'	on	    on
コマンドの文字			'showcmd'	on	    off
カーソルの位置			'ruler'		off	    off

現在のモードとは、"-- INSERT --" や "-- REPLACE --" のことです、'showmode' を
参照。コマンドの文字とは、入力されて、まだ実行されていないコマンドのことです。

遅い端末を使っている場合は、ステータスメッセージをオフにすることで編集のスピー
ドを上げることができます: >
	:set nosc noru nosm

エラーが起きたとき、エラーメッセージは少なくとも一秒間は表示されます(反転表示
で)。

いくつかのコマンドでは、そのコマンドが作用する行数が表示されます。何行以上でそ
の表示をするかは、'report' で設定できます (初期設定は 2)。

Vim の名前と現在のファイル名の絶対パスがタイトルバーに表示されます。ウィンドウ
がリサイズされると、Vim は自動的にウィンドウを再描画します。ウィンドウは好きな
だけ小さくできますが、小さすぎると1行のみで収まりきらなくなります。最下行に表
示されるメッセージが読めるように、最低でも40文字の幅を取ってください。

==============================================================================
用語の定義						*definitions* *jargon*

- バッファ		テキスト行が入っている。一般にファイルから読み込む。
- スクリーン		Nvim が描画に使う領域全体。
- ウィンドウ		バッファが表示される場所。1 つのバッファが複数のウィ
			ンドウを持つことが可能。
- frame: Windows are kept in a tree of frames.  Each frame contains a column,
  row, or window ("leaf" frame).
- フレーム              ウィンドウはフレームのツリー内に保持される。各フレーム
                        は行、列、ウィンドウを持つ("leaf" フレーム)。

一つのスクリーンは一つ以上のウィンドウを内包し、それらはステータスラインで区切
られ、最下行にはコマンドラインが表示されます。
>
        +-------------------------------+
 screen | window 1      | window 2      |
        |               |               |
        |               |               |
        |= status line =|= status line =|
        | window 3                      |
        |                               |
        |                               |
        |==== status line ==============|
        |command line                   |
        +-------------------------------+
<
コマンドラインはメッセージを表示するためにも使われます。コマンドラインに十分な
表示領域がない場合はスクリーンがスクロールします。

行には 4 種類あり、次の違いがあります:

- バッファ行		バッファ内の行。ファイルに読み書きする行のこと。
			行の長さは制限なし。
- 論理行		折り畳みが適用されたバッファ行。複数のバッファ行が折り
			畳まれ論理行 1 行となり、次のように表示される:
			"+-- 99 lines folded"。
			行の長さは制限なし。
- ウィンドウ行		ウィンドウに表示される行: 折り返し、ラインブレークなど
			が適用された後の論理行の一部。長さはウィンドウの幅以
			下。それ以上長い行は折り返されるか切り詰められる。
- スクリーン行		Nvim が使うスクリーンの行。全てのウィンドウのウィンド
                        ウ行とステータスライン、コマンドラインからなる。長さは
                        スクリーンの幅以下。コマンドラインがそれ以上長くなった
                        ときは折り返して表示され、表示領域を作るために行がスク
                        ロールされる。

>
  バッファ行	  論理行	  ウィンドウ行	  スクリーン行
  -----------------------------------------------------------------------
  1. one          1. one          1. +-- folded   1.  +-- folded
  2. two          2. +-- folded   2. five         2.  five
  3. three        3. five         3. six          3.  six
  4. four         4. six          4. seven        4.  seven
  5. five         5. seven                        5.  === status line ===
  6. six                                          6.  aaa
  7. seven                                        7.  bbb
                                                  8.  ccc ccc c
  1. aaa          1. aaa          1. aaa          9.  cc
  2. bbb          2. bbb          2. bbb          10. ddd
  3. ccc ccc ccc  3. ccc ccc ccc  3. ccc ccc c    11. ~
  4. ddd          4. ddd          4. cc           12. === status line ===
                                  5. ddd          13. (command line)
                                  6. ~
<

API クライアント ~
すべての外部UI及びリモートプラグイン(通常のプラグインとは異なる)は、一般的には
「クライアント」です。しかし、他のアプリケーションの利便性のために、RPC API を
抽象化したりラップすることを目的としている場合は、「API クライアント」と呼びま
す(AWS の boto3 などの REST クライアントや SDK と同様です: 通常 AWS REST を
curl のような HTTPクライアントを通じて記述しますが、boto3 はそれを利便な
Python インターフェイスでラップします)。例を挙げると、Nvim Node クライアント
は、API クライアントです:
    https://github.com/neovim/node-client


ホスト ~
プラグイン「ホスト」は、(Nvim API の)クライアントとサーバー(外部プラットフォー
ム、例えば Python など)の両方の機能を持ちます。これはつまり、他のプラグインを
ホストするリモートプラグインということになります。


リモートプラグイン ~
リモートプラグインは、 |:UpdateRemotePlugins| 経由で登録された任意のコードです。
別のプロセスで実行され、 |api| 経由で Nvim と通信します。


 vim:tw=78:ts=8:et:sw=4:ft=help:norl:
