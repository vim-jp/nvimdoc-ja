*luaref.txt*           Nvim 0.12        Last change: 2025-08-24
                                                                *luaref*

                           LUA リファレンスマニュアル


                                 Version 0.3.0
                                August 7th, 2022


                    Vimdoc version (c) 2006 by Luis Carvalho
                         <lexcarvalho at gmail dot com>

                    Adapted from "Lua: 5.1 reference manual"
                 R. Ierusalimschy, L. H. de Figueiredo, W. Celes
                      Copyright (c) 2006 Lua.org, PUC-Rio.


              このマニュアルについての情報は |lua-ref-doc| を参照。
              著作権とライセンスについては |lua-ref-copyright| を参照。


目次を確認するには |gO| をタイプ。

==============================================================================
0  日本語訳について

この文書は、 Lua 5.1 Reference Manual を原著者に無断で日本語に訳した、非公式の
Lua 5.1 リファレンスマニュアルである。

==============================================================================
1  概要                                                         *luaref-intro*

Luaは拡張プログラミング言語である。 データ記述機能を持ち、汎用の手続き型プログ
ラミングをサポートするようデザインされた。 オブジェクト指向プログラミング、関
数型プログラミング、データ駆動型プログラミングもサポートしている。 Luaは、パワ
フルで軽いスクリプト言語として、それらが必要なあらゆるプログラムに使われること
を意図している。 Luaは クリーンな C (つまり、ANSI C と C++ の共通のサブセット)
で書かれ、ライブラリとして実装されている。

拡張言語であるため、Luaは「メイン」プログラムを持たない。 ホストクライアント
(エンベッディングプログラム、あるいは単にホスト とも呼ぶ) に 組み込まれて 動く
だけである。 このホストプログラムは、Luaコードを実行する関数を呼び出したり、Lu
aの変数を読み書きしたり、Luaから呼ばれるCの関数を登録したりできる。 Cの関数を
使ってカスタマイズすることで、共通の構文を持つプログラミング言語で様々な領域を
広範囲にカバーすることができる。

Luaはフリーソフトウェアであり、ライセンスにも書かれているように、いかなる保証
もなくあるがまま提供される。 このマニュアルに記述されている実装はLuaの公式ウェ
ブサイト www.lua.org で提供されている。

他のすべてのリファレンスマニュアルと同様、この文書はあちこちが無味乾燥である。
Luaのデザインの背後にある決定についての議論は、 |lua-ref-bibliography| を参照。
Luaによるプログラミングの詳しい紹介は、Roberto著 Programming in Lua を参照。

Lua とはポルトガル語で「月」を意味し、 LOO-ah と発音する。

==============================================================================
2  言語                                                 *lua-language*

このセクションでは、Luaの字句、構文、意味論について記述する。 言い換えると、こ
のセクションでは、どういったトークンが有効か、それらをどう組み合わせられるの
か、そしてその組み合わせは何を意味するのかについて記述している。 

言語構造は一般的な拡張BNF記法を使って説明する。 `{ a }` は `a` の0回以上の繰り返
し、`[ a ]` は `a` が省略可能であることを表す。

==============================================================================
2.1  字句の構成                                         *lua-lexical*

                                               *lua-names* *lua-identifiers*
Luaの 名前 (識別子 とも呼ばれる) は、文字、数字、アンダースコアを組み合わせた
任意の文字列である。 ただし数字で始まってはならない。 これは多くの言語の名前の
定義に一致する。 「文字」の定義は現在のロケールに依存する。 現在のロケールでア
ルファベットとみなされる文字はどれも識別子に使える。 識別子は名前変数やテーブ
ルフィールドに使われる。

以下の キーワード は予約されており、名前としては使えない。 
>
       and       break     do        else      elseif
       end       false     for       function  if
       in        local     nil       not       or
       repeat    return    then      true      until     while
<
Lua は大文字小文字を区別する言語である。 `and` は予約語だが、 `And` と `AND` は、2つ
の異なった、有効な名前である。 慣習的に、アンダースコアと大文字で始まる名前 
(例えば `_VERSION`) は、 Luaが使う内部のグローバル変数として予約されている。

以下の文字列は、その他のトークンである。 
>
       +     -     *     /     %     ^     #
       ==    ~=    <=    >=    <     >     =
       (     )     {     }     [     ]
       ;     :     ,     .     ..    ...
<
                                                                *lua-literal*
文字列リテラル は対になるシングルクォートかダブルクォートで囲まれ、 以下の C 
のようなエスケープシーケンスを含むことができる。 

    - `\a`  ベル
    - `\b`  バックスペース
    - `\f`  改ページ
    - `\n`  改行
    - `\r`  復帰
    - `\t`  水平タブ
    - `\v`  垂直タブ
    - `\\`  バックスラッシュ (円記号)
    - `\"`  引用符 (ダブルクォート)
    - `\'`  アポストロフィ (シングルクォート)

上記に加えて、 `\改行` (バックスラッシュに本物の改行が続いたもの) を記述して文字
列中に改行を含めることができる。 さらに `\ddd` (dddは最大3桁の10進数) というエス
ケープシーケンスを使って 文字列中の文字をそのコード値で指定することもできる。
(数値エスケープの後に数字が続く場合は、ぴったり3桁使って表現しなければならな
い。) Luaの文字列は `\0 `で表されるゼロを含み、いかなる8ビット値も含むことができ
る。

ダブル(またはシングル)クォートで囲まれた文字列リテラルの中に、 ダブル(またはシ
ングル)クォート、改行、バックスラッシュ、または埋め込まれたゼロを置くためには、
エスケープシーケンスを使わなければならない。 他のすべての文字は直接リテラルの
中に入れて構わない (ファイルシステムに対しては制御文字が問題を起こすかもしれな
いが、Luaは大丈夫である。)

文字列リテラルは 長括弧 で囲む長い形式を使って定義することもできる。 n 段の開
き長括弧 は、 開き角括弧に n 個のイコールと、さらに開き角括弧を続けたものであ
る。つまり、0段の開き長括弧は `[[` と書き、 1段の開き長括弧は `[=[` と書き、以下同
様である。 閉じ長括弧 も同様である。 例えば4段の閉じ長括弧は `]====]` と書く。長
い文字列は任意の段数の開き長括弧で始まり、同じ段数の閉じ長括弧で終わる。 この
角カッコ形式のリテラルは、複数行に渡って記述できる。 エスケープシーケンスは一
切解釈されず、異なる段数の閉じ長括弧は無視する。 これは、正しい段数の閉じ長括
弧と埋め込まれたゼロ以外の任意の内容を入れられる。

便利なように、開き長括弧のすぐ後に改行が続いたときは、その改行は文字列に含まれ
ない。 例えば、ASCII (つまり `a` が97、改行が10、 `1` が49であるような文字コード)
が使われているシステムでは、 以下の4つのリテラルは同じ文字列を表現している。
>lua
       a = 'alo\n123"'
       a = "alo\n123\""
       a = '\97lo\10\04923"'
       a = [[alo
       123"]]
       a = [==[
       alo
       123"]==]
<
                                                            *lua-numconstant*
数値定数 には省略可能な小数部と省略可能な指数部を書くことができる。 Luaは接頭
辞 `0x` を付けた整数の16進定数も受け付ける。 有効な数値定数の例を挙げると 
>
     3     3.0     3.1416  314.16e-2   0.31416E1   0xff   0x56
<
                                                                *lua-comment*
コメント は文字列の外ならどこでも、二つのハイフン (`--`) で始めることができる。
もし `--` の直後に開き長括弧以外のテキストがあれば、そのコメントは 短いコメント
であり、行末まで続く。 そうでなければ、それは 長いコメント であり、対応する閉
じ長括弧まで続く。 長いコメントはコードを一時的に無効にするためによく使われる。 

==============================================================================
2.2  値と型                                     *lua-values*

Luaは 動的な型の言語 である。 つまり、変数は型を持たず、値が型を持つ。 型定義
の構文はない。 すべての値は自分自身で型を保持している。

Luaのすべての値は ファーストクラスの値 である。 つまり、いかなる値も変数に格納
でき、他の関数に引数で渡すことができ、戻り値として返すことができる。 

                                                *lua-types* *lua-nil*
                                                *lua-true* *lua-false*
                                                *lua-number* *lua-string*
Luaには8つの基本型がある。 `nil`、 `ブーリアン`、 `数値`、 `文字列` 、 `関数`、
`ユーザーデータ`、  `スレッド`、 `テーブル` である。 nil は nil 値の型である。その
主な性質は他のいかなる値とも異なることであり、通常、役に立つ値がないことを表す
。 ブーリアン は `false` と `true` の値を持つ型である。 `nil` と `false` は共に条件判
断で偽となり、他の値は真となる。 数値 は実数 (double) を表現する。 (しかし数値
の内部表現としてfloatやlongなど他の型を使うようLuaインタプリタをビルドし直すの
は簡単である。 ファイル `luaconf.h` を参照。) 文字列 は文字の配列を表現する。
Luaは8ビットクリーンであり、 文字列にはゼロ (`\0`) を含むいかなる8ビット文字も含
むことができる (|lua-literal| を参照)。

LuaはLuaで書かれた関数もCで書かれた関数も呼べる (|lua-function| を参照)。 

                                                            *lua-userdatatype*
ユーザーデータ は任意のCのデータをLuaの変数に格納するために用意された。 この型
は生のメモリブロックに相当し、代入と等価比較を除いて、Luaでは演算が定義されて
いない。 しかしながら、メタテーブル を用いることで、 プログラマはユーザーデー
タに対する演算を定義することができる (|lua-metatable| を参照)。 ユーザーデータ
はLua内で作ったり変更することはできず、CのAPIを通してのみ可能である。 これは完
全にホストプログラムに所有されたデータであることを保証する。 

                                                                 *lua-thread*
`スレッド` は実行されているそれぞれのスレッドを表現し、コルーチンを実装するため
に使われる (|lua-coroutine| を参照)。 LuaのスレッドとOSのスレッドを混同しない
ように。 Luaはスレッドをサポートしないシステム上でもコルーチンをサポートする。 

                                                                  *lua-table*
`テーブル` は連想配列である。 すなわち数値だけでなく任意の値 (`nil` を除く) をキー
にできる配列である。 テーブルは 異種混合 できる。 つまりあらゆる型の値 (`nil` を
除く) を持つことができる。 テーブルはLuaの唯一のデータ構造であり、 普通の配列
の他、記号表、集合、レコード、グラフ、ツリーなどを表現するために使われる。 レ
コードを表現するときは、フィールド名をインデックスとして使う。 このための
`a.name` という表現が `a["name"]` のシンタックスシュガーとして用意されている。ま
た、Luaでテーブルを作るための便利な表現がいくつかある (|lua-tableconstructor|
を参照)。 

インデックスと同様、テーブルフィールドの値には任意の型 (`nil` を除く) を格納でき
る。 特に、関数がファーストクラスであるため、テーブルフィールドは関数を格納す
ることができる。 そのためテーブルは メソッド を持つことができる
(|lua-function-define| を参照)。 

テーブル、関数、スレッド、ユーザーデータの値は オブジェクト である。 変数はこ
れらの実際の値は持たず、それらを 参照 しているだけである。 代入、引数渡し、関
数の戻り値は、常に値への参照を扱い、値のコピーは行われない。 

ライブラリ関数 `type` は与えられた値の型を表す文字列を返す(|lua-type()|を参照)。 

------------------------------------------------------------------------------
2.2.1  変換                                                *lua-coercion*

Luaは文字列と数値を実行時に自動的に変換する。 すべての数学演算は、文字列に適用
されると、一般的な変換ルールに基づいてその文字列を数値に変換しようとする。 逆
に、文字列が期待されるところで数値が使れると、その数値は一般的な形式の文字列に
変換される。 数値が文字列に変換される方法を完璧にコントロールする場合は、 文字
列ライブラリの `format` 関数を使う (|string.format()| を参照)。 

==============================================================================
2.3  変数                                                 *lua-variables*

変数は値を格納する場所である。 Luaには、グローバル変数、ローカル変数、テーブル
フィールドの三種類の変数がある。 

単発の名前はグローバル変数かローカル変数を表す (または関数の仮引数かもしれない
が、それはローカル変数の一種である)。 
>
       var ::= Name
<
(|lua-lexical| を参照) で定義されているように、名前は識別子を表す。 

明示的にローカルと宣言されない限り、変数はグローバルとみなされる (|lua-local| を
参照)。 ローカル変数は レキシカルスコープ を持ち、 そのスコープ内で定義された
関数から自由にアクセスできる (|lua-visibility| を参照)。 

最初の代入が行われる前の変数の値は `nil` である。

テーブルをインデックス付けするためには角カッコを使う。 
>
       var ::= prefixexp [ exp ]
<
最初の式 (`prefixexp`) はテーブル、 二番目の式 (`exp`) はテーブル内のエントリを指
定する値でなければならない。 テーブルのインデックスを指定する式は限定された構
文を持つ。 詳細は |lua-expressions| を参照。 

構文 `var.Name` は `var["Name"]` の単なるシンタックスシュガーであり、 テーブルフィ
ールドを示すために使う。 
>
       var ::= prefixexp . Name
<
すべてのグローバル変数は、環境テーブル または単に 環境 (|lua-environments| を参
照) と呼ばれる通常のLuaのテーブル内に、フィールドとして存在している。 各関数は
それぞれ独自に環境への参照を持ち、 その関数内でのすべてのグローバル変数は、そ
の環境テーブルを参照する。 関数が作られたとき、関数は、それが作られた関数から
見える環境を受け継ぐ。 Luaの関数の環境テーブルを取得するには `getfenv`
(|lua_getfenv()|を参照)を呼ぶ。 変更するには `setfenv` (|setfenv()|を参照)を呼ぶ。
(Cの関数の環境はデバッグライブラリでのみ操作できる (|lua-lib-debug| を参照)。) 


グローバル変数 `x` へのアクセスは `_env.x` と等価であり、 以下と等価である。 
>lua
       gettable_event(_env, "x")
<
ただし、`_env` は関数が実行されている環境を表す (変数 `_env` はLuaで定義されてい
ない。 これはただ説明のために用いているだけである)。 

The meaning of accesses to global variables and table fields can be changed
グローバル変数とテーブルフィールドへアクセスする効果はメタテーブルによって変え
られる。 インデックス付き変数 `t[i]` へのアクセスは `gettable_event(t,i)` の呼び出
しと等価である (`gettable_event` 関数の完全な説明は |lua-metatable| を参照。 この
関数はLuaで定義したり呼ぶことはできず、単に説明のため用いているだけである)。 

==============================================================================
2.4  文                                         *lua-statement*

LuaはPascalやCと同じように一般的な文のセットをサポートしている。 代入、制御構
造、関数呼び出し、テーブルコンストラクタや変数の宣言などである。 

------------------------------------------------------------------------------
2.4.1  チャンク                                 *lua-chunk*

Luaの実行の単位は チャンク と呼ばれる。 チャンクは、単純に、順番に実行される文
の連なりである。 それぞれの文末には省略可能なセミコロンを置いても良い。 
>
       chunk ::= {stat [ ; ]}
<
空文は存在しないため、 `;;` は許されていない。

Luaはチャンクを、可変個の引数を持つ無名関数の本体として扱っている
(|lua-function-define| を参照)。 従って、チャンクはローカル変数を宣言でき、引数
を受け取ることができ、戻り値を返せる。 

チャンクはファイルやホストプログラム内の文字列として格納されているであろう。
チャンクが実行されるとき、まず仮想マシンの命令にコンパイルされ、それからコンパ
イル済みコードが仮想マシンのインタプリタによって実行される。 

チャンクはバイナリ形式のコンパイル済みコードであっても良い。 詳細は `luac` プロ
グラムを参照。 ソースプログラムとコンパイル済み形式はどちらを用いても良い。
Luaは自動的にファイル形式を検出し、適切に振る舞う。 

------------------------------------------------------------------------------
2.4.2  ブロック                                 *lua-block*

文の列はブロックである。 構文的には、ブロックはチャンクと等しい。 
>
       block ::= chunk
<
                                                *lua-do* *lua-end*
ブロックは明示的に単一の文とすることもある。 
>
       stat ::= do block end
<
明示的なブロックは変数宣言スコープをコントロールするのに便利である。 明示的な
ブロックはまた、 他のブロックの途中に `return` 文や `break` 文を入れるために使うこ
ともある。 (|lua-control|を参照)

------------------------------------------------------------------------------
2.4.3  代入                                     *lua-assign*

Luaは多重代入を許している。 だから、代入文では左辺に変数リスト、右辺に式リスト
を書く。 どちらのリストもそれぞれの要素をカンマで区切る。 
>
       stat ::= varlist1 = explist1
       varlist1 ::= var { , var }
       explist1 ::= exp { , exp }
<
式については |lua-expressions| で議論する。 

代入の前に、値リストは変数リストの長さに調節される。 もし必要な数よりも値が多
ければ、余分な値は捨てられる。 もし必要な数よりも値が少なければ、必要なだけ
`nil` が追加される。 もし式リストの最後が関数呼び出しなら、調節の前に、その関数
のすべての戻り値が値リストに追加される (ただし呼び出しをカッコで囲った場合を除
く、|lua-expressions| を参照)。 

代入文は、まずすべての式を評価し、それから、代入が行われる。だから、このコード 
>lua
       i = 3
       i, a[i] = i+1, 20
<
は、 `i` に4が代入される前に `a[i]` の `i` が (3に) 評価されるため、 `a[3]` に20が代入
される。 `a[4]` は何の影響もない。 同様に、 
>lua
       x, y = y, x
<
は `x` と `y` の値を交換する。 

グローバル変数とテーブルフィールドへの代入の効果は、メタテーブルによって変えら
れる。 インデックス付き変数への代入 `t[i] = val` は `settable_event(t,i,val)` と等
価である (`settable_event` 関数の完全な記述は |lua-metatable| を参照。 この関数は
Luaで定義したり呼ぶことはできず、 ただ説明のため用いているだけである)。 

グローバル変数への代入 `x = val` は代入 `_env.x = val` と等価であり、 以下と等価で
ある。 
>lua
       settable_event(_env, "x", val)
<
ただし、`_env` は関数が実行されている環境を表す (変数 `_env` はLuaに定義されてい
ない。 これはただ説明のために用いているだけである)。 

------------------------------------------------------------------------------
2.4.4  制御構造                                         *lua-control*

                                   *lua-if* *lua-then* *lua-else* *lua-elseif*
                                   *lua-while* *lua-repeat* *lua-until*
制御構造 `if`、 `while`、 `repeat` は一般的な意味とよく知られた構文をしている。
>
       stat ::=  while  exp do block end
       stat ::=  repeat  block until exp
       stat ::=  if  exp then block { elseif exp then block }
                 [ else block ] end
<
Luaには `for` 文もある。 これは2つの種類がある (|lua-for| を参照)。 

制御構造の条件式は任意の値をとれる。 `false` と `nil` は共に偽である。 `nil` と
`false` 以外のすべての値は真になる (特に、数値の0や空文字列は真であることに注
意)。 

`repeat-until` ループでは、 内側のブロックは `until` キーワードのところではなく条
件式の後に終わる。 つまり、条件式はループブロックの内側で宣言されたローカル変
数を参照できる。 

                                                                 *lua-return*
`return` 文は関数やチャンク (これはただの関数である) から値を返すために使う。 関
数やチャンクは1個以上の値を返すことができる。 `return` 文の構文は以下の通り。

       `stat ::=`  `return`  `[explist1]`

                                                                  *lua-break*
`break` 文は `while`、`repeat`、`for` ループの実行を終了し、 ループの次までスキッ
プする。 

       `stat ::=`  `break`

`break` は最も内側のループを終わらせる。 

`return` 文と `break` 文はブロックの `最後` の文としてのみ書くことが許される。
`return` や `break` をブロックの途中で使うことが本当に必要なら、 明示的な内部ブロ
ックを使う次のような慣用句を使えば良い。 
>
    do return end
    do break end
<
これで `return` も `break` も (内部) ブロックの最後の文になる。 

------------------------------------------------------------------------------
2.4.5  for文                                     *for* *lua-for*

`for` 文には、数値用と汎用の2つの形式がある。 

数値用 `for` ループは制御変数が等差数列を辿ってコードブロックを繰り返す。 以下が
その構文である。
>
       stat ::=  for  Name = exp , exp [ , exp ] do block end
<
`block` は `name` が最初の `exp` で始まって二番目の `exp` に達するまで、 三番目の `exp`
ずつ進む間、繰り返される。 より正確には、次のような `for` 文

       `for var =  e1, e2, e3  do  block  end`

は次のコードに等しい。 >lua

       do
         local  var, limit, step  = tonumber(e1), tonumber(e2), tonumber(e3)
         if not (  var  and  limit  and  step  ) then error() end
         while (  step  >0 and  var  <=  limit  )
                 or (  step  <=0 and  var  >=  limit  ) do
            block
            var  =  var  +  step
         end
       end
<

以下の点に注意:

 - 3つの制御式はループが始まる前に一度だけ評価される。これらは数値でなければな
   らない。
 - `var`、 `limit`、 `step` は見えない変数である。 この名前は説明のために用いられて
   いるだけである。
 - もし三番目の式 (ステップ) が省略されたら、1が使われる。
 - `for` ループを脱出するためには `break` を使う
 - ループ変数 `var` はループ内でローカルである。 `for` 文の外側でその値を使うこと
   はできない。 もしループ変数 `var` の値が必要なら、 ループを出る前に別の変数に
   代入する必要がある。

                                                                      *for-in*
汎用 `for` 文は イテレータ (|iterator|) と呼ばれる関数を通して働く。 それぞれの繰
り返しについて、新しい値を生成するためにイテレータ関数が呼ばれ、 `nil` になった
ところで止まる。 汎用 `for` ループは以下の構文である。
>
       stat ::=  for  namelist in explist1 do block end
       namelist ::= Name { , Name }
<
次のような `for` 文

       `for`  `var1, ..., varn`  `in`  `explist`  `do`  `block`  `end`

は次のコードと等価である。 >lua

       do
         local  f, s, var  =  explist
         while true do
             local  var1, ..., varn  =  f(s, var)
             var  =  var1
             if  var  == nil then break end
             block
         end
       end
<
以下の点に注意:

 - `explist` は一度だけ評価され、 イテレータ 関数、 `状態`、繰り返し変数 の初期
   値、でなければならない。
 - `f`、 `s`、 `var` は見えない変数である。 この名前は説明のために用いられているだけ
   である。
 - `for` ループを脱出するためには `break` を使う
 - ループ変数 `var` はループ内でローカルである。 `for` 文の外側でその値を使うこと
   はできない。 もしループ変数 `var` の値が必要なら、 ループを出る前に別の変数に
   代入する必要がある。

------------------------------------------------------------------------------
2.4.6  文としての関数呼び出し                 *lua-funcstatement*

副作用を許しているため、関数呼び出しは文として実行できる。
>
       stat ::= functioncall
<
この場合、戻り値はすべて捨てられる。 関数呼び出しは |lua-function| で説明する。

------------------------------------------------------------------------------
2.4.7  ローカル宣言                           *lua-local*

ローカル変数はブロックの中どこででも宣言できる。 宣言は初期値の代入を伴っても
よい。
>
       stat ::=  local  namelist [ = explist1 ]
       namelist ::= Name { , Name }
<
もしあれば、多重代入と同じ構文で初期値が代入される (|lua-assign| を参照)。 そう
でなければ、変数はすべて `nil` で初期化される。

チャンクもまたブロックであるから (|lua-chunk| を参照)、 明示的なブロックの外側の
チャンクでもローカル変数を宣言できる。 そのようなローカル変数のスコープはチャ
ンクの終わりまで続く。

ローカル変数の可視ルールは |lua-visibility| で説明する。

==============================================================================
2.5  式                                                 *lua-expressions*

Luaの基本の式を以下に示す。
>
       exp ::= prefixexp
       exp ::=  nil  |  false  |  true
       exp ::= Number
       exp ::= String
       exp ::= function
       exp ::= tableconstructor
       exp ::= ...
       exp ::= exp binop exp
       exp ::= unop exp
       prefixexp ::= var | functioncall | ( exp )
<
数値と文字列リテラルは |lua-lexical| で説明した。 変数は |lua-variables| で説明し
た。 関数定義は |lua-function-define| で説明する。 関数呼び出しは |lua-function|
で説明する。 テーブルコンストラクタは |lua-tableconstructor| で説明する。 3つの
ドット(`...`)で表される可変引数式は、可変引数関数の中でだけ使える。 これは
|lua-function-define| で説明する。

`not` (see |lua-logicalop|), and the unary length operator (see |lua-length|).
二項演算子は算術演算子 (|lua-arithmetic| を参照)、 関係演算子 (|lua-relational| を
参照)、 論理演算子 (|lua-logicalop| を参照)、連結演算子 (|lua-concat| を参照) があ
る。 単項演算子は単項マイナス(|lua-arithmetic| を参照)、 単項 `not` (|lua-logicalop|
を参照)、 そして単項 長さ演算子 (|lua-length| を参照) がある。

関数呼び出しと可変引数式は複数の値を返す。 式が文として使われた場合
(|lua-funcstatement| を参照) (関数呼び出しに対してのみ可能)、 結果のリストはゼロ
個に調節され、つまりすべての戻り値が捨てられる。 他の式の中やリストの途中で使
われた場合は、 結果のリストは1個に調節され、残りはすべて捨てられる。 式がリス
トの最後の要素として使われた場合は、 調節は行われない (カッコで囲った場合を除
く)。 

いくつか例を挙げる。
>lua
       f()                -- 戻り値は0個に調節される
       g(f(), x)          -- f()の戻り値は1個に調節される
       g(x, f())          -- xに加えてf()のすべての戻り値をgに渡す
       a,b,c = f(), x     -- f()の戻り値は1個に調節される (そしてcにはnilが入
                          -- る)
       a,b = ...          -- aに可変引数の最初の値、bに2番目の値が入る
                          -- (対応する引数がなかった場合、a、bにはnilが入る)
       a,b,c = x, f()     -- f()の戻り値は2個に調節される
       a,b,c = f()        -- f()の戻り値は3個に調節される
       return f()         -- f()の戻り値をすべて返す
       return ...         -- 渡された可変引数をすべて返す
       return x,y,f()     -- x、yとf()のすべての戻り値を返す
       {f()}              -- f()のすべての戻り値からなるリストを作る
       {...}              -- 渡された可変引数すべての値からなるリストを作る
       {f(), nil}         -- f()の戻り値が1個に調節される
<
カッコに囲まれた式は常にただ1つの値を返す。 つまり、たとえ `f` が複数の値を返し
ても、 `(f(x,y,z))` は常に単一の値となる。 `(f(x,y,z))` の値は、 `f` が返す最初の値
である。 あるいは `f` が何も返さなければ、 `nil` となる。

------------------------------------------------------------------------------
2.5.1  算術演算子                                           *lua-arithmetic*

Luaは一般的な算術演算子をサポートしている。 `+` (加算)、 `-` (減算)、 `*` (乗算)、
`/` (除算)、 `%` (剰余)、 `^` (累乗)、 および単項の `-` (符号反転)。 もしオペランドが
数値、あるいは数値に変換できる文字列 (|lua-coercion|を参照) なら、すべての演算は
通常の意味を持つ。 累乗は任意の指数に対して動作する。 例えば、 `x^(-0.5)` は `x`
の平方根の逆数を計算する。 剰余は以下のように定義されている。
>lua
       a % b == a - math.floor(a/b)*b
<
つまり、負の無限大に向かって丸められた割り算の余りである。 

------------------------------------------------------------------------------
2.5.2  関係演算子                                             *lua-relational*

Luaの関係演算子は以下の通りである。
>
                    ==    ~=    <     >     <=    >=
<
これらの演算子は常に `false` か `true` いずれかの結果を返す。

等価 (`==`) はまずオペランドの型を比較する。 もし型が異なっていたら、結果は
`false` である。 そうでなければ、オペランドの値が比較される。 数値と文字列は一般
的な方法で比較する。 オブジェクト (テーブル、ユーザーデータ、スレッド、関数)
は 参照 を比較し、 2つのオブジェクトが 同じ オブジェクトである場合だけを等しい
とみなす。 新しいオブジェクト (テーブル、ユーザーデータ、関数) を作ったときは
常に、 この新しいオブジェクトは、以前に存在していたオブジェクトと異なる。

"eq"メタメソッドを使って、テーブルやユーザーデータをLuaが比較する方法を変えら
れる (|lua-metatable| を参照)。

変換 (|lua-coercion|) の変換ルールは等価比較には適用されない。 そのため、 `"0"==0`
は `false` に評価され、 `t[0]` と `t["0"]` は異なったテーブルエントリを示す。 

演算子 `~=` は正確に等価 `(==)` の否定である。 

関係演算子は次のように働く。 引数が両方数値ならば、それらは適切に比較される。
もし両方の引数が文字列ならば、現在のロケールに従ってその値が比較される。そうで
なければ、Luaは"lt"または"le"メタメソッドを試みる (|lua-metatable| を参照)。 

------------------------------------------------------------------------------
2.5.3  論理演算子                                             *lua-logicalop*

Luaの論理演算子は次の通りである。 
>
       and    or    not
<
制御構造 (|lua-control| を参照) と同じく、 すべての論理演算子は `false` と `nil` の
両方を偽、それ以外のすべてを真とみなす。 

                                                  *lua-not* *lua-and* *lua-or*
否定演算子 `not` は常に `false` か `true` を返す。 論理積演算子 `and` は、最初の引数が
`false` か `nil` ならその値を返し、そうでなければ二番目の引数を返す。 論理和演算子
`or` は最初の引数が `false` か `nil` 以外ならその値を返し、そうでなければ二番目の引
数を返す。 `and` と `or` は共にショートカット評価を行う。 つまり、二番目のオペラン
ドは、それが必要なときだけ評価される。 いくつかの例を示す。
>
       10 or 20            --> 10
       10 or error()       --> 10
       nil or "a"          --> "a"
       nil and 10          --> nil
       false and error()   --> false
       false and nil       --> false
       false or nil        --> nil
       10 and 20           --> 20
<
(このマニュアルでは `-->` で式の結果を示す。) 

------------------------------------------------------------------------------
2.5.4  連結                                                  *lua-concat*

Luaの文字列連結演算子はふたつのドット (`..`) で表す。 もし両方のオペランドが文
字列か数値なら、それらは |lua-coercion| で述べたルールに従って文字列に変換され
る。 そうでなければ、"concat"メタメソッドが呼ばれる (|lua-metatable| を参照)。 

------------------------------------------------------------------------------
2.5.5  長さ演算子                                            *lua-#* *lua-length*

長さ演算子は単項演算子 `#` で表される。 文字列の長さはそのバイト数である (つま
り、各文字が1バイトだとした場合の、文字列の長さである)。 

テーブル `t` の長さは、 `t[n]` が `nil` でなく `t[n+1]` が `nil` であるような整数 `n` と定
義されている。 また、 `t[1]` が `nil` なら `n` はゼロになりうる。 `nil` でない値が1か
ら `n` まで格納されている普通の配列では、 その長さは最後のインデックス `n` を正し
く返す。 配列に「穴」がある場合 (つまり間に `nil` がある場合)、 `#t` はどれかの
`nil` のひとつ前を返すかもしれない (つまり、その `nil` が配列の終わりであるように
見えるのだ)。

------------------------------------------------------------------------------
2.5.6  優先順位                                                *lua-precedence*

Luaでの演算子の優先順位を以下の表に示す。 優先順位は低い方から順に
>
       or
       and
       <     >     <=    >=    ~=    ==
       ..
       +     -
       *     /
       not   #     - (unary)
       ^
<
普通通りに、カッコを使って式の優先順位を変えることができる。 連結 (`..`) と累乗
(`^`) は右結合である。 他の二項演算子はすべて左結合である。

------------------------------------------------------------------------------
2.5.7  テーブルコンストラクタ                            *lua-tableconstructor*

テーブルコンストラクタはテーブルを作る式である。 コンストラクタが評価されるた
びに新しいテーブルが作られる。 空のテーブルを作ることも、いくつかのフィールド
に初期値を持ったテーブルを作ることもできる。 コンストラクタの構文は以下の通り
である。
>
       tableconstructor ::= { [ fieldlist ] }
       fieldlist ::= field { fieldsep field } [ fieldsep ]
       field ::= [ exp ]  = exp | Name = exp | exp
       fieldsep ::=  , |  ;
<
`[exp1] = exp2` 形式のフィールドは、 キー `exp1` と値 `exp2` を持つエントリをテーブ
ルに追加する。 `name = exp` 形式のフィールドは `["name"] = exp` と等価である。 最
後の `exp` 形式のフィールドは、 `[i] = exp` と同じである。 ここで `i` は1から始まる
連続した整数であり、他の形式のフィールドはこのカウンタに影響を与えない。例えば
>lua
       a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
<
は以下と等価である。
>lua
       do
         local t = {}
         t[f(1)] = g
         t[1] = "x"         -- 1st exp
         t[2] = "y"         -- 2nd exp
         t.x = 1            -- temp["x"] = 1
         t[3] = f(x)        -- 3rd exp
         t[30] = 23
         t[4] = 45          -- 4th exp
         a = t
       end
<
もし最後のフィールドが `exp` 形式で、その式が関数呼び出しか可変引数式であれば、
その戻り値がすべてリストに追加される (|lua-function| を参照)。 これを避けるに
は、関数呼び出し(あるいは可変引数式)をカッコで囲む (|lua-expressions| を参照)。 

自動生成コードに便利なように、各フィールドの終わりに省略可能なセミコロンを付け
ても良い。

------------------------------------------------------------------------------
2.5.8  関数呼び出し                       *lua-function*

Luaの関数呼び出しは以下の構文である。
>
       functioncall ::= prefixexp args
<
関数呼び出しでは、 まず `prefixexp` と `args` が評価される。 もし `prefixexp` の値が
`関数` であれば、与えられた引数でその関数が呼ばれる。 そうでなければ、 `prefixexp`
の "call" メタメソッドが呼ばれる。 そのとき `prefixexp` が最初の引数として渡さ
れ、二番目以降に元々の引数が続く (|lua-metatable| を参照)。

書式
>
       functioncall ::= prefixexp : Name args
<
は「メソッド」と呼ばれる。 呼び出し `v:name( args )` は `v.name(v, args )` のシン
タックスシュガーであり、 `v` の評価がただ一度である点だけが異なる。

引数は以下の構文を持つ。
>
       args ::=  ( [ explist1 ] )
       args ::= tableconstructor
       args ::= String
<
引数のすべての式は呼び出し前に評価される。 `f{ fields }` は `f({ fields })` のシン
タックスシュガーであり、新しいテーブルひとつが引数となる。 `f' string '` (および
`f" string "` や `f[[ string ]]`) は `f(' string ')` のシンタックスシュガーであり、
引数は文字列リテラルひとつである。 

Luaのフリーフォーマット構文の例外として、 関数呼び出しの `(` の直前で改行するこ
とはできない。 この制限によって言語の曖昧さが避けられる。 つまり、この制限がな
かった場合、もし次のように書くと
>lua
       a = f
       (g).x(a)
<
Luaは単一の式 `a = f(g).x(a)` と解釈したかもしれない。 この場合、2つの文にしたけ
れば間にセミコロンが必要である。 だか実際には、 `f` を呼びたければ `(g)` の前の改
行を取り除かなければならない。

                                                               *lua-tailcall*
`return functioncall` のような呼び出し形式は 終端呼び出し と呼ばれる。 Luaは 終
端呼び出し最適化 (または 終端再帰最適化) を実装している。 終端呼び出しでは、呼
び出された関数は呼び出し側関数のスタックエントリを再利用する。 その結果、終端
呼び出しのネスト数の制限なしに (無限に再帰呼び出しして) プログラムを実行でき
る。 しかしながら、終端呼び出しは呼び出し側関数に関するデバッグ情報を消してし
まう。 終端呼び出しは、単一の関数呼び出しで `return` するという特別な状況でのみ
起こることに注意。 この構文では、呼び出した関数の戻り値がそのまま呼び出し側関
数の戻り値になる。 よって、以下の例はどれも終端呼び出しではない。
>lua
       return (f(x))        -- 戻り値が1個に調節されている
       return 2 * f(x)      -- 戻り値が加工されている
       return x, f(x)       -- 戻り値が追加されている
       f(x); return         -- 戻り値が捨てられている
       return x or f(x)     -- 戻り値が1個に調節されている
<

------------------------------------------------------------------------------
2.5.9  関数定義                                 *lua-function-define*

関数定義の構文を以下に示す。 
>
       function ::= function funcbody
       funcbody ::= ( [ parlist1 ] ) block end
<
以下のシンタックスシュガーは関数定義を単純化する。
>
       stat ::= function funcname funcbody
       stat ::= local function Name funcbody
       funcname ::= Name { . Name } [ : Name ]
<
以下の文

       `function f ()`  `body`  `end`

は次のように変換される。

       `f = function ()`  `body`  `end`

以下の文

       `function t.a.b.c.f ()`  `body`  `end`

は次のように変換される。

       `t.a.b.c.f = function ()`  `body`  `end`

以下の文

       `local function f ()`  `body`  `end`

は次のように変換される。

       `local f; f = function f ()`  `body`  `end`

次のようにではない。

       `local f = function f ()`  `body`  `end`

(この違いは、関数の中で `f` を参照できるかどうかである。)

                                                                *lua-closure*
関数定義は実行可能な式であり、 `関数` 型の値を持つ。 Luaがチャンクをコンパイルす
ると、 その中にある関数の本体もコンパイルされる。 そして、Luaが関数定義を実行
したとき、 関数は インスタンス化 (または クローズ) される。 この関数インスタン
ス (または クロージャ) は式の最終的な値である。 同じ関数の異なるインスタンスは
異なるローカル変数と異なる環境テーブルを参照する場合がある。

仮引数はローカル変数として振る舞い、渡された実引数の値で初期化される。
>
       parlist1 ::= namelist [ , ... ] | ...
<
                                                                 *lua-vararg*
関数が呼ばれると、実引数リストは仮引数リストの長さに調節される。 ただし、仮引
数リストの最後が3つのドット (`...`) である 可変引数 の場合を除く。 可変引数で
は実引数が調節されず、 代わりに余分の実引数はすべて 可変引数式 によって関数に
渡される。 可変引数式もまた3つのドットで書く。 この式の値は、すべての余分の実
引数からなるリストである。 これは複数の戻り値を持つ関数に似ている。 可変引数式
が他の式の中やリストの途中で使われた場合は、 結果のリストは要素が1個に調節され
る。 リストの最後の要素で使われた場合は、 調節は行われない(カッコで囲った場合
を除く)。

例として、以下の定義を考える。
>lua
       function f(a, b) end
       function g(a, b, ...) end
       function r() return 1,2,3 end
<
この場合、実引数から仮引数と可変引数式へ以下のようにマッピングされる。
>
       呼び出し         仮引数

       f(3)             a=3, b=nil
       f(3, 4)          a=3, b=4
       f(3, 4, 5)       a=3, b=4
       f(r(), 10)       a=1, b=10
       f(r())           a=1, b=2

       g(3)             a=3, b=nil, ... -->  (なし)
       g(3, 4)          a=3, b=4,   ... -->  (なし)
       g(3, 4, 5, 8)    a=3, b=4,   ... -->  5  8
       g(5, r())        a=5, b=1,   ... -->  2  3
<
関数の結果を返すには `return` 文を使う (|lua-control| を参照)。 `return` 文に出会わ
ずに制御が関数の終わりまで達したら、関数は何も返さない。

                                                            *lua-colonsyntax*
コロン 構文を使って メソッド を定義できる。 メソッドとは、暗黙の引数 `self` を余
分に持つ関数である。 つまり、以下の構文

       `function t.a.b.c:f (`  `params`  `)`  `body`  `end`

は、以下の文のシンタックスシュガーである。

       `t.a.b.c:f = function (`  `self`,  `params`  `)`  `body`  `end`

==============================================================================
2.6  可視ルール                                          *lua-visibility*

Luaはレキシカルスコープを持つ言語である。 変数のスコープは、それが宣言された文
の 次 から始まり、 その宣言を含む最も内側のブロックのendで終わる。 以下の例を
考えよう。
>lua
       x = 10                -- グローバル変数
       do                    -- 新しいブロック
         local x = x         -- 新しい変数 `x'、値は 10
         print(x)            --> 10
         x = x+1
         do                  -- 別のブロック
           local x = x+1     -- 別の新しい `x'
           print(x)          --> 12
         end
         print(x)            --> 11
       end
       print(x)              --> 10  (グローバル変数)
<
`local x = x` のような宣言に注意。 新しく定義された `x` はまだスコープに入っていな
いので、 右辺の `x` は外側の変数を参照する。

                                                                *lua-upvalue*
レキシカルスコープのルールにより、 ローカル変数はそのスコープの内側に定義され
た関数から自由にアクセスできる。 内部関数から使われるローカル変数は、 内部関数
の中では 上位値 または 外部ローカル変数 と呼ばれる。

local 文を実行するたびに新しいローカル変数が宣言されることに注意。 以下の例を
考えよ。
>lua
       a = {}
       local x = 20
       for i=1,10 do
         local y = 0
         a[i] = function () y=y+1; return x+y end
       end
<
このループは10個のクロージャ (つまり匿名関数の10個のインスタンス) を作る。 ク
ロージャはすべて同じ `x` を共有するが、 それぞれ異なった `y` を持つ。

==============================================================================
2.7  エラー処理                                               *lua-errors*

Luaは組み込み拡張言語であるから、 すべてのLuaアクションはホストプログラムのCの
コードがLuaライブラリの関数を呼ぶことによってスタートする (|lua_pcall()| を参
照)。 Luaのコンパイル中や実行中でエラーが起きたときは、制御がCに返され、 適切
な動作を行うことができる (例えばエラーメッセージを出すとか)。

Luaコードは `error` 関数 (|error()|を参照) を呼ぶことで明示的にエラーを起こすこと
ができる。 もしLua内でエラーを捕らえる必要があれば、 `pcall` 関数を使えばよい
(|pcall()|を参照)。

==============================================================================
2.8  メタテーブル                       *metatable* *lua-metatable*

Luaのどの値も メタテーブル を持つことができる。 メタテーブル はLuaの通常のテー
ブルであるが、 その値に対して特殊な演算をしたときの挙動を定義する。 メタテーブ
ルのフィールドを設定することで、オブジェクトの動作をいくつかの面で変えることが
できる。 例えば、数値以外の値が加算のオペランドになったとき、 Luaはメタテーブ
ルの `"__add"` フィールドをチェックする。 もしそれが見つかれば、加算を行うために
その関数が呼ばれる。

メタテーブルのキーを イベント、値を メタメソッド と呼ぶ。 前の例でいう
と、"add" がイベントで、加算を行う関数がメタメソッドである。

`getmetatable` 関数で任意の値のメタテーブルを取り出すことができる
(|getmetatable()|を参照)。

テーブルのメタテーブルは `setmetatable` 関数で変更できる(|setmetatable()|を参照)。
他の型のメタテーブルをLuaで変えることはできない (デバッグライブラリを除く)。
そのためにはCのAPIを使わなければならない。

テーブルとユーザーデータは独立したメタテーブルを持つことができる (複数のテーブ
ルやユーザーデータが同じメタテーブルを共有することもできる)。 他の型の値は、型
ごとに単一のメタテーブルを共有する。 つまりすべての数値に対してひとつだけメタ
テーブルが存在し、 すべての文字列に対してひとつだけメタテーブルが存在し、 以下
同様である。

メタテーブルは、算術演算、関係比較、連結、長さ演算子、インデックス付けについ
て、オブジェクトがどう振る舞うかを制御する。 また、ユーザーオブジェクトに関し
ては、オブジェクトがガベージコレクトされたときに呼ばれる関数も定義できる。 各
演算には イベント と呼ばれる特殊なキーが関連付けられている。 Luaが値に対してこ
れらの演算を行うとき、 その値がメタテーブルを持っていてイベントが設定されてい
るかチェックされる。 キーに割り当てられた値 (メタメソッド) はLuaがその演算をど
う行うかをコントロールする。

メタテーブルがコントロールできる演算を以下に示す。 各演算は関連付けられた名前
で区別される。 各演算のキーは、その名前の前に2つのアンダースコア `__` が付く文
字列である。 例えば、"add"演算のキーは、文字列 "__add" である。 これらの演算の
効果は、いかに演算が実行されるかを記述したLuaの関数で説明する。

ここにLuaのコードを示しているのは、単に説明のためである。 実際はインタプリタに
ハードコードされており、この擬似コードよりも効率的に動作する。 ここで使われて
いる関数 (`rawget`、 `tonumber` など) は |lua-lib-core| に記述されている。 与えられ
たオブジェクトのメタメソッドを取り出すコードとして、以下の表現を用いているが、
>
       metatable(obj)[event]
<
これは次のように読んでもらいたい。
>lua
       rawget(metatable(obj) or {}, event)
<
つまり、メタメソッドへのアクセスで他のメタメソッドを呼び出すことはなく、 オブ
ジェクトがメタメソッドを持っていなくてもエラーを起こすことはない (その場合は単
に `nil` を返す)。

"add":                                                                 *__add()*
------
`+` 演算。

<
以下の `getbinhandler` 関数は二項演算でLuaがどのようにハンドラを選ぶかを定義す
る。 まずLuaは最初のオペランドについて試みる。 もしその型が、その演算について
ハンドラを定義していなければ、 二番目のオペランドを試みる。
>lua
       function getbinhandler (op1, op2, event)
         return metatable(op1)[event] or metatable(op2)[event]
       end
<
この関数を使って `op1 + op2` の挙動を示すと、
>lua
       function add_event (op1, op2)
         local o1, o2 = tonumber(op1), tonumber(op2)
         if o1 and o2 then  -- 両方のオペランドが数値か?
           return o1 + o2   -- この `+´ はプリミティブな加算
         else  -- 少なくとも片方は数値ではない
           local h = getbinhandler(op1, op2, "__add")
           if h then
             -- 両方のオペランドに対してハンドラを呼ぶ
             return h(op1, op2)
           else  -- ハンドラがない、デフォルトの動作
             error("...")
           end
         end
       end
<
"sub":                                                                 *__sub()*
------
`-` 演算。 "add"演算と同じように動作する。

"mul":                                                                 *__mul()*
------
`*` 演算。 "add"演算と同じように動作する。

"div":                                                                 *__div()*
------
`/` 演算。 "add"演算と同じように動作する。

"mod":                                                                 *__mod()*
------
`%` 演算。 "add"演算と同じように動作する。 プリミティブ演算として
`o1 - floor(o1/o2)*o2` を使う。

"pow":                                                                 *__pow()*
------
`^` (累乗) 演算。 "add"演算と同じように動作する。 プリミティブ演算として関数 `pow`
(Cの数学ライブラリ) を使う。

"unm":                                                                 *__unm()*
------
単項 `-` 演算。
>lua
       function unm_event (op)
         local o = tonumber(op)
         if o then  -- オペランドは数値か？
           return -o  -- この `-´ はプリミティブな符号反転
         else  -- オペランドは数値でない
           -- オペランドからハンドラを取り出す
           local h = metatable(op).__unm
           if h then
             -- オペランドに対してハンドラを呼ぶ
             return h(op)
           else  -- ハンドラがない、デフォルトの動作
             error("...")
           end
         end
       end
<
"concat":                                                           *__concat()*
---------
`..` (連結) 演算。
>lua
       function concat_event (op1, op2)
         if (type(op1) == "string" or type(op1) == "number") and
            (type(op2) == "string" or type(op2) == "number") then
           return op1 .. op2  -- プリミティブ文字列連結
         else
           local h = getbinhandler(op1, op2, "__concat")
           if h then
             return h(op1, op2)
           else
             error("...")
           end
         end
       end
<
"len":                                                                 *__len()*
------
`#` 演算。
>lua
       function len_event (op)
         if type(op) == "string" then
           return strlen(op)         -- プリミティブの文字列長
         elseif type(op) == "table" then
           return #op                -- プリミティブのテーブル長
         else
           local h = metatable(op).__len
           if h then
             -- オペランドに対してハンドラを呼ぶ
             return h(op)
           else  -- ハンドラがない、デフォルトの動作
             error(...)
           end
         end
       end
<
"eq":                                                                   *__eq()*
-----
`==` 演算。

関数 `getcomphandler` は、比較演算子のメタメソッドをLuaがどのように選ぶかを定義
する。 両方のオブジェクトが同じ型で、その演算に対して同じメタメソッドを持つ場
合だけ、 メタメソッドが選択される。
>lua
       function getcomphandler (op1, op2, event)
         if type(op1) ~= type(op2) then return nil end
         local mm1 = metatable(op1)[event]
         local mm2 = metatable(op2)[event]
         if mm1 == mm2 then return mm1 else return nil end
       end
<
"eq"イベントは次のように定義される。
>lua
       function eq_event (op1, op2)
         if type(op1) ~= type(op2) then  -- 型が異なるか?
           return false   -- 異なるオブジェクト
         end
         if op1 == op2 then   -- プリミティブのイコール
           return true   -- オブジェクトは等しい
         end
         -- メタメソッドを試す
         local h = getcomphandler(op1, op2, "__eq")
         if h then
           return h(op1, op2)
         else
           return false
         end
       end
<
`a ~= b` は `not (a == b)` と等価である。

"lt":                                                                   *__lt()*
-----
`<` 演算。
>lua
       function lt_event (op1, op2)
         if type(op1) == "number" and type(op2) == "number" then
           return op1 < op2   -- 数値の比較
         elseif type(op1) == "string" and type(op2) == "string" then
           return op1 < op2   -- 辞書順の比較
         else
           local h = getcomphandler(op1, op2, "__lt")
           if h then
             return h(op1, op2)
           else
             error(...);
           end
         end
       end
<
`a > b` は `b < a` と等価である。

"le":                                                                   *__le()*
-----
`<=` 演算。
>lua
       function le_event (op1, op2)
         if type(op1) == "number" and type(op2) == "number" then
           return op1 <= op2   -- 数値の比較
         elseif type(op1) == "string" and type(op2) == "string" then
           return op1 <= op2   -- 辞書順の比較
         else
           local h = getcomphandler(op1, op2, "__le")
           if h then
             return h(op1, op2)
           else
             h = getcomphandler(op1, op2, "__lt")
             if h then
               return not h(op2, op1)
             else
               error(...);
             end
           end
         end
       end
<
`a >= b` は `b <= a` と等価である。 "le"メタメソッドがなければ、 Luaは `a <= b` を
`not (b < a)` とみなして"lt"を試みることに注意。

"index":                                                             *__index()*
--------
`table[key]` インデックスアクセス。
>lua
       function gettable_event (table, key)
         local h
         if type(table) == "table" then
           local v = rawget(table, key)
           if v ~= nil then return v end
           h = metatable(table).__index
           if h == nil then return nil end
         else
           h = metatable(table).__index
           if h == nil then
             error(...);
           end
         end
         if type(h) == "function" then
           return h(table, key)      -- ハンドラを呼ぶか、
         else return h[key]          -- 演算を繰り返す
       end
<
"newindex":                                                       *__newindex()*
-----------
`table[key] = value` インデックス代入。
>lua
       function settable_event (table, key, value)
         local h
         if type(table) == "table" then
           local v = rawget(table, key)
           if v ~= nil then rawset(table, key, value); return end
           h = metatable(table).__newindex
           if h == nil then rawset(table, key, value); return end
         else
           h = metatable(table).__newindex
           if h == nil then
             error(...);
           end
         end
         if type(h) == "function" then
           return h(table, key,value)    -- ハンドラを呼ぶか、
         else h[key] = value             -- 演算を繰り返す
       end
<
"call":                                                               *__call()*
-------
値を関数呼び出ししたときに呼ばれる。
>lua
       function function_event (func, ...)
         if type(func) == "function" then
           return func(...)   -- プリミティブの関数呼び出し
         else
           local h = metatable(func).__call
           if h then
             return h(func, ...)
           else
             error(...)
           end
         end
       end
<

==============================================================================
2.9  環境                                       *lua-environments*

スレッド、関数、ユーザーデータ型のオブジェクトは、 メタテーブルに加えてもうひ
とつ、 関連付けれられたテーブルを持つ。 これを 環境 と呼ぶ。 メタテーブル同様、
環境も普通のテーブルである。

ユーザーデータに関連付けられた環境はLuaにとっては意味を持たない。 これはプログ
ラマのために、 ユーザーデータにテーブルを関連付ける機能として存在するだけであ
る。

スレッドに関連付けられた環境は グローバル環境 と呼ぶ。 これは、スレッドと、ス
レッドが作成した (|loadfile()|、 |loadstring()| または |load()| を使って) ネストされ
ていない関数のデフォルトの環境として使われ、 Cのコードで直接アクセスできる
(|lua-pseudoindex| を参照)。

Cの関数に関連付けられた環境はCのコードで直接アクセスできる (|lua-pseudoindex| を
参照)。 またその関数で作成する他のCの関数のデフォルトの環境として使われる。

Luaの関数に関連付けられた環境は、 その関数の中でアクセスするグローバル変数を解
決するために使われる (|lua-variables| を参照)。 またその関数で作成する他のLuaの
関数のデフォルトの環境として使われる。

`setfenv` を呼ぶと走行中のスレッドや Lua の関数の環境を変更できる。 `getfenv` を呼
ぶと走行中のスレッドや Lua の関数の環境を取得できる(|lua_getfenv()|を参照)。 他
のオブジェクト (ユーザーデータ、Cの関数、他のスレッド) の環境を操作するには、
CのAPIを使わなければならない。

==============================================================================
2.10  ガベージコレクション                                       *lua-gc*

Luaは自動的にメモリを管理する。 つまり、新しいオブジェクトのためのメモリ確保
や、オブジェクトが要らなくなったときの解放について、悩まなくてよい。 Luaは死ん
だオブジェクト (もうアクセスできなくなったオブジェクト) を回収する ガベージコ
レクタ を時々実行することで、自動的にメモリを管理する。 テーブル、ユーザーデー
タ、関数、スレッド、文字列といったすべてのLuaオブジェクトは自動管理の対象であ
る。

Luaはインクリメンタルマークアンドスイープコレクタを実装している。 ガベージコレ
クションの周期を制御するために2つの数値、 ガベージコレクタ停止値 と ガベージコ
レクタステップ係数 を使うことができる。

ガベージコレクタ停止値は、 どれだけ経ったら新しいサイクルを開始するかを制御す
る。 値が大きいほどコレクタが消極的になる。 1より小さな値にすると、コレクタが
すぐに新しいサイクルを開始する。 2にすると、使われているメモリの合計が2倍になっ
たらコレクタが新しいサイクルを開始する。

ステップ係数は、メモリ確保に対するコレクタの相対速度を制御する。 値が大きいほ
どコレクタは積極的になるが、 各インクリメンタルステップのサイズが大きくなる。
1より小さな値にすると、コレクタは非常に遅くなり、結果としてサイクルが終わらな
いかもしれない。 デフォルトの2では、メモリ確保の「2倍」の速度でコレクタが動作
する。

Cの `lua_gc` (|lua_gc()|を参照) か Luaの `collectgarbage` (|collectgarbage()|を参照)を
呼ぶと、これらの値を変更できる。 いずれもパーセント値で引数を取る (従って 100
を渡すと 1.00 を意味する)。 これらの関数でコレクタを直接制御できる (停止させた
り再開させたり)。

------------------------------------------------------------------------------
2.10.1  ガベージコレクションメタメソッド                     *lua-gc-meta*

CのAPIを使う場合、ユーザーデータにガベージコレクタメタメソッドを設定できる
(|lua-metatable|を参照)。 このメタメソッドは ファイナライザ と呼ばれることもあ
る。 ファイナライザはLuaのガベージコレクタを外部リソースと共に使えるようにする
(ファイルやネットワーク接続、データベース接続などを閉じたり、独自に確保したメ
モリを解放するとか)。

                                                                          *__gc*
メタテーブルに `__gc` フィールドを持つユーザーデータがガベージになっても、ガベー
ジコレクタはそれをすぐには回収しない。 その代わり、Luaはそれをリストに入れる。
他のオブジェクトの回収が終わったあと、Luaはリスト内のユーザーデータに対して以
下の関数と同等のことを行う。
>lua
       function gc_event (udata)
         local h = metatable(udata).__gc
         if h then
           h(udata)
         end
       end
<
各ガベージコレクションサイクルの終わりに、 作られたときと 逆の順番で ユーザー
データのファイナライザが呼ばれる。 つまり、最初に呼ばれるファイナライザは、一
番最近に作られたユーザーデータのものである。

------------------------------------------------------------------------------
2.10.2 - 弱参照テーブル                         *lua-weaktable*

弱参照テーブル は 弱参照 な要素を持つテーブルである。 弱参照はガベージコレクタ
に無視される。 言い換えると、オブジェクトへの参照が弱参照のみであれば、ガベー
ジコレクタはそのオブジェクトを回収してしまう。

                                                                        *__mode*
弱参照テーブルは、キー、値、あるいはその両方が弱参照である。 弱参照キーを持つ
テーブルは、キーは回収されるが、その値は回収されない。 弱参照キーと弱参照値の
両方を持つテーブルでは、キーも値も回収の対象になる。 キーと値のどちらか一方が
回収されると、キーと値のペア全体がテーブルから除去される。 テーブルの弱参照の
性質は、メタテーブルの `__mode` フィールドで制御できる。 もし `__mode` フィールド
が文字列で、文字 `k` が含まれていたら、テーブルのキーが弱参照となる。 もし
`__mode` フィールドが文字 `v` を含んでいたら、テーブルの値が弱参照となる。

メタテーブルとして使った後に、そのテーブルの `__mode` フィールドの値を変更するべ
きではない。 このメタテーブルで制御されているテーブルの弱参照の挙動が未定義と
なる。

==============================================================================
2.11  コルーチン                                *lua-coroutine*

Luaはコルーチンをサポートしている。 協調的マルチスレッド と呼ばれることもある。
Luaのコルーチンは独立に実行されるスレッドを表現している。 マルチスレッドシステ
ムのスレッドとは違って、 コルーチンはyield関数を呼んで明示的に実行を中断しなけ
ればならない。

コルーチンを作るには `coroutine.create` を呼ぶ(|coroutine.create()|を参照)。 これ
はひとつだけ引数をとり、それにコルーチンのメイン関数を渡す。 `create` 関数は新し
いコルーチンを作成し、その `スレッド` オブジェクトを返す。 コルーチンはすぐには
実行されない。

`coroutine.create` から返されたスレッドを最初の引数に渡して最初に
`coroutine.resume` を呼んだとき(|coroutine.resume()|を参照)、 そのメイン関数の最初
の行からコルーチンの実行が始まる。 `coroutine.resume` に余分の引数を指定すると、
それらはコルーチンのメイン関数に渡される。 コルーチンが開始されたら、終わりに
達するか `yield` を呼ぶまで実行される。

コルーチンは2つの方法で実行を終われる。 メイン関数からreturnして (明示的にか、
最後の命令が終わって暗黙的にか) 正常終了したときと、 保護されないエラーが起き
て異常終了したときである。 最初の場合では、 `true` と、メイン関数からの戻り値
を、 `coroutine.resume` が返す。 エラーの場合は、 `coroutine.resume` は `false` とエ
ラーメッセージを返す。

コルーチンは `coroutine.yield` を呼ぶことで中断される(|coroutine.yield()|を参照)。
コルーチンが中断されると、対応する `coroutine.resume` からすぐに戻る。 コルーチ
ンの中で呼ばれた関数の中で中断されても同様である (つまり、メイン関数から直接
的/間接的に呼ばれた、メイン関数以外の関数の中でも)。 この場合も、
`coroutine.resume` は `true` を返す。 `coroutine.yield` に引数が渡されていれば、それ
も返される。 次に同じコルーチンを resumeすると、中断した場所から実行が再開され
る。 `coroutine.resume` に余分な引数を渡すと、 `coroutine.yield` からそれらが返さ
れる。

`coroutine.wrap` 関数(|coroutine.wrap()|を参照)は `coroutine.create` と同様にコルー
チンを作成するが、 コルーチン自身を返すのではなく、コルーチンをresumeする関数
を返す。 その関数に渡された引数は `coroutine.resume` に追加の引数として渡される。
`coroutine.resume` からの戻り値は、最初のひとつ (ブーリアン型のエラーコード) を
除いた残りが返される。 `coroutine.resume` と違って、 この関数はエラーを捕らえる
ことはなく、内部で起きたエラーは呼び出した側に伝搬する。

例として、次のコードを考える。
>lua
       function foo1 (a)
         print("foo", a)
         return coroutine.yield(2*a)
       end

       co = coroutine.create(function (a,b)
             print("co-body", a, b)
             local r = foo1(a+1)
             print("co-body", r)
             local r, s = coroutine.yield(a+b, a-b)
             print("co-body", r, s)
             return b, "end"
       end)

       print("main", coroutine.resume(co, 1, 10))
       print("main", coroutine.resume(co, "r"))
       print("main", coroutine.resume(co, "x", "y"))
       print("main", coroutine.resume(co, "x", "y"))
<
これを実行すると、以下の出力を得る。
>
       co-body 1       10
       foo     2
       main    true    4
       co-body r
       main    true    11      -9
       co-body x       y
       main    true    10      end
       main    false   cannot resume dead coroutine
<

==============================================================================
3  アプリケーションプログラムインタフェイス                         *lua-API*

このセクションではLuaのためのCのAPIを説明する。 これは、ホストプログラムがLua
に働きかけるためのCの関数のセットである。 すべてのAPI関数と、関連する型、定数
は、ヘッダーファイル `lua.h` で定義されている。

このマニュアルでは「関数」という言葉を使うが、代わりに `マクロ` として提供されて
いるものもある。 そのようなマクロはすべて、各引数がちょうど一度だけ評価され、
いかなる隠れた副作用も発生しない (ただし最初の引数を除く。ここには常にLuaステー
トを渡す)。

ほとんどのCのライブラリと同様に、 LuaのAPI関数は引数の妥当性や一貫性をチェック
しない。 しかし、ファイル `luaconf.h` の中のマクロ `luai_apicheck` を適切に定義し
てLuaを再コンパイルすると、この動作を変更できる。

==============================================================================
3.1  スタック                                     *lua-stack* *lua-apiStack*

LuaはCとの間で値を受け渡しするために 仮想スタック を使う。 スタック内の各要素
は、Luaの値 (`nil`、数値、文字列など) を表している。

LuaがCを呼ぶときは、以前のスタックの状態やまだアクティブなCの関数が使っている
スタックに影響されないように、新しいスタックを用意する。 このスタックはCの関数
に渡された引数が格納されており、 Cの関数から呼び出し側に返す戻り値を格納するた
めにも使われる (|lua_CFunction| を参照)。

                                                             *lua-stackindex*
利便性のため、ほとんどの問い合わせ用API関数は厳密なスタックの規則に従っていな
い。 代わりに、インデックス を使って、スタック内の任意の要素にアクセスできる。
プラスのインデックスはスタック内の 絶対 位置を表し (1 から始まる)、 マイナスの
インデックスはスタックトップからの相対 オフセット を表す。 具体的に言うと、ス
タックに `n` 個の要素があるとして、 インデックス1は最初の要素 (つまり、空のス
タックに最初に積まれた要素) を表し、 インデックス `n` は最後の要素を表す。 イン
デックス `-1` も最後の要素 (つまりスタックトップにある要素) を表し、 インデック
ス `-n` は最初の要素を表す。 有効な インデックスは1からスタックトップの間だけで
ある(つまり `1 <= abs(index) <= top`)。

==============================================================================
3.2  スタックサイズ                                        *lua-apiStackSize*

LuaのAPIを使うときは、一貫性を保証する責任がある。 特に、スタックオーバーフロー
に気を付けなければならない。 スタックサイズを伸ばすためには関数 `lua_checkstack`
を使う(|lua_checkstack()|を参照)。

LuaがCを呼ぶときは、 最低でも全体で `LUA_MINSTACK` 個のスタック要素が利用可能で
ある。 `LUA_MINSTACK` は20に定義されており、 スタックにどんどん要素を積むような
ループがあったりしなければ、 普通はスタック空間を気にしなくても良い。

多くの問い合わせ関数には、スタック空間内で利用可能な任意のインデックス値を使え
る。 つまり、 `lua_checkstack` を使って設定できる最大スタックの長さまでのイン
デックスである。 このようなインデックスは 受け入れ可能なインデックス と呼ぶ。
もっと正確には、受け入れ可能なインデックス は以下のように定義される。
>lua
    (index < 0 && abs(index) <= top) || (index > 0 && index <= stackspace)
<
0は決して受け入れ可能なインデックスにならない。

==============================================================================
3.3  疑似インデックス                                   *lua-pseudoindex*

特に明記されていなければ、 どの関数も 疑似インデックス と呼ばれる有効なインデッ
クスを受け付ける。 これはスタック内に無いいくつかのLuaの値にCのコードからアク
セスするためのものである。 疑似インデックスは、スレッドの環境、関数の環境、レ
ジストリ、Cの関数の上位値にアクセスするために使う (|lua-cclosure| を参照)。

スレッドの環境 (グローバル変数がある場所) は常に擬似インデックス
`LUA_GLOBALSINDEX` の位置にある。 走行中のCの関数の環境は常に擬似インデックス
`LUA_ENVIRONINDEX` の位置にある。

グローバル変数の値にアクセスしたり変更するためには、 環境テーブルに対して普通
のテーブル操作を行う。 例えば、グローバル変数の値にアクセスするには以下を行う。
>c
       lua_getfield(L, LUA_GLOBALSINDEX, varname);
<

==============================================================================
3.4  Cのクロージャ                                      *lua-cclosure*

Cの関数を作成するとき、いくつかの値を関連付けて Cのクロージャ を作ることができ
る。 これらの値は 上位値 と呼ばれ、 その関数が呼ばれたときにいつでもアクセスで
きる。 (|lua_pushcclosure| を参照)。

Cの関数が呼ばれると、特別な疑似インデックスにこれらの値が配置される。 これらの
疑似インデックスはマクロ `lua_upvalueindex` で生成される。 関数に関連付けられた
最初の値は `lua_upvalueindex(1)` の位置にあり、残りも同様である。 現在の関数の上
位値の数よりも大きい `n` で `lua_upvalueindex(n)` を呼び出しても、 受け入れ可能な
(ただし有効でない) インデックスが生成される。

==============================================================================
3.5  レジストリ                                         *lua-registry*

Luaはレジストリを提供している。 これは定義済みのテーブルで、好きなLuaの値を格
納するためにCのコードから使うことができる。 このテーブルは常に疑似インデックス
`LUA_REGISTRYINDEX` に置かれている。 どのCのライブラリもデータを保持するためにこ
のテーブルを使えるが、 衝突を避けるため他のライブラリが使っていないキーを選ぶ
必要がある。 典型的には、ライブラリ名を含む文字列とか、自分のコードで使ってい
るCオブジェクトのアドレスを持つライトユーザーデータを、キーとして使うと良い。

レジストリ内の整数キーは、補助ライブラリで実装されているリファレンスメカニズム
で使われており、それゆえ他の目的に使うべきでない。

==============================================================================
3.6  Cでのエラー処理                                    *lua-apiError*

内部的に、Luaはエラー処理のためにCの `longjmp` の機能を使う。 (C++を使っているの
なら、例外を使うこともできる。 `luaconf.h` ファイルを参照。) Luaがエラーに直面す
ると (メモリ不足とか、型エラーとか、構文エラーとか、実行時エラーなど)、 エラー
を 発生 させ、つまるところロングジャンプが行われる。 保護された環境 は復帰点を
セットするために `setjmp` を使い、 エラーは最も最近作られたアクティブ復帰点にジャ
ンプすることになる。

APIのほとんどの関数はエラー、例えばメモリ確保エラーなどを起こす可能性がある。
以下の関数は保護モード (つまり、実行するために保護された環境を作る) で実行する
ため、決してエラーを起こさない。 `lua_newstate`, `lua_close`, `lua_load`, `lua_pcall`,
そして `lua_cpcall`(|lua_newstate()|, |lua_close()|, |lua_load()|, |lua_pcall()|,
|lua_cpcall()|を参照)。

`lua_error` を呼ぶと、CのコードからLuaのエラーを発生させることが出来る
(|lua_error()|を参照)。


==============================================================================
3.7  関数と型                                              *lua-apiFunctions*

以下にCのAPIのすべての関数と型をアルファベット順に示す。

lua_Alloc                                                            *lua_Alloc*
>c
    typedef void * (*lua_Alloc) (void *ud,
                                 void *ptr,
                                 size_t osize,
                                 size_t nsize);
<
        Luaステートが使うメモリアロケータ関数の型である。 メモリアロケータ関数
        は `realloc` に似た機能を提供しなければならないが、 まったく同じではな
        い。 引数は以下の通り。 `ud`: `lua_newstate` に渡されたポインタ
        (|lua_newstate()| を参照)。 `ptr`: 割り当て/再割り当て/解放するブロックへ
        のポインタ。 `osize`: 元のブロックサイズ。 `nsize`: 新しいブロックサイズ。
        `osize` がゼロの場合、またその場合に限り、 `ptr` は `NULL`になる。 `nsize` が
        ゼロの場合、アロケータは `NULL` を返さなければならない。 `osize` がゼロで
        ない場合、 `ptr` が指すメモリブロックを解放すべきである。 `nsize` がゼロ
        でない場合、要求を満たせなければアロケータは `NULL` を返す。 `nsize` がゼ
        ロでなく `osize` がゼロの場合、アロケータは `malloc` のように振る舞うべき
        である。 `nsize` と `osize` が共にゼロでない場合、アロケータは `realloc` の
        ように振る舞う。 `osize >=nsize` であれば、Luaはアロケータが決して失敗し
        ないものと仮定している。

        アロケータ関数の簡単な実装を示そう。 これは `lua_newstate` が補助ライブ
        ラリで使っている(|luaL_newstate()| を参照)。
>c
            static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                       size_t nsize) {
              (void)ud;  (void)osize;  /* not used */
              if (nsize == 0) {
                free(ptr);  /* ANSIはfree(NULL)は効果がないと規定している */
                return NULL;
              }
              else
                /* ANSIはrealloc(NULL, size)はmalloc(size)と同じと規定している */
                return realloc(ptr, nsize);
            }

lua_atpanic                                                      *lua_atpanic()*
>c
    lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
<
        新しいパニック関数を設定し、古いものを返す。

        保護された環境の外側でエラーが起きると、Luaは `パニック関数` を呼び、そ
        れから `exit(EXIT_FAILURE)` を呼んでホストアプリケーションを終了する。
        パニック関数が戻らなければ(例えばロングジャンプするとかで)、終了しない
        ようにできる。

        パニック関数はスタックの一番上にあるエラーメッセージにアクセスできる。

lua_call                                                            *lua_call()*
>c
    void lua_call (lua_State *L, int nargs, int nresults);
<
        関数を呼ぶ。

        関数を呼ぶには、以下の手順に従わなければならない。 まず、呼びたい関数
        をスタックに積む。 次に、その関数に渡す引数を順番通りに積む。 つまり最
        初の引数を最初に積む。 最後に、 `lua_call` を呼ぶ。 `nargs` はスタックに積
        んだ引数の数である。 すべての引数と関数の値は関数を呼んだときにスタッ
        クから取り除かれる。 関数が戻るとき、スタックに戻り値が積まれる。 戻り
        値の数は `nresults` 個に調節される。 ただし `nresults` が `LUA_MULTRET` の場
        合は調節されない。 この場合、関数の `すべて`の 戻り値が積まれる。 Luaは
        戻り値をスタック空間に合うようにする。 関数の戻り値は順番通りに (最初
        の戻り値が最初に) スタックに積まれる。 従って呼び出し後のスタックの一
        番上は、その最後の戻り値である。

        呼び出した関数の中で起きたエラーは上に伝搬される(`longjmp`を使って)。

        以下のLuaコードと等価なことをホストプログラムからはどうすれば良いのか
        の例を示す:
>lua
            a = f("how", t.x, 14)
<
        これをCで書くと:
>c
            lua_getfield(L, LUA_GLOBALSINDEX, "f");           /* 呼ぶ関数 */
            lua_pushstring(L, "how");                       /* 最初の引数 */
            lua_getfield(L, LUA_GLOBALSINDEX, "t");        /* テーブル't' */
            lua_getfield(L, -1, "x");     /* t.xの結果(2番目の引数)を積む */
            lua_remove(L, -2);             /* スタックから 't' を取り除く */
            lua_pushinteger(L, 14);                        /* 3番目の引数 */
            lua_call(L, 3, 1);      /* 3個の引数と1個の戻り値で関数を呼ぶ */
            lua_setfield(L, LUA_GLOBALSINDEX, "a");    /* グローバル変数 'a'
                                                                   に代入 */
<
        上のコードは「整合が取れている」ことに注目。 最終的にスタックは元の状
        態に戻っている。 これは良いプログラミング作法であると考えられる。

lua_CFunction                                   *lua-cfunction* *lua_CFunction*
>c
    typedef int (*lua_CFunction) (lua_State *L);
<
        Cの関数の型。

        適切にLuaとやりとりするに、Cの関数は、 引数と戻り値の受け渡し方法を定
        義する以下の手順に従わなければならない。 Cの関数はLuaからの引数をスタッ
        クに順番通り受け取る (最初の引数が最初に積まれる)。 つまり、関数の開始
        時点では、 `lua_gettop(L)` (|lua_gettop()| を参照) は関数が受け取った引数
        の数を返す。 最初の引数 (もしあれば)はインデックス1で、最後の引数はイ
        ンデックス `lua_gettop(L)` である。 Luaに値を返すには、Cの関数は単にス
        タックにその値を順番通り (最初の戻り値を最初に) 積み、戻り値の数を返す
        だけで良い。 戻り値より下のスタックにある余計な値はすべてLuaによって捨
        てられる。 Luaの関数と同様、Luaから呼ばれるCの関数でも、たくさんの戻り
        値を返すことができる。

                                                       *lua-cfunctionexample*
        例として、可変個の数値の引数を取り、その平均と合計を返す関数を以下に示
        す。
>c
            static int foo (lua_State *L) {
              int n = lua_gettop(L);    /* 引数の数 */
              lua_Number sum = 0;
              int i;
              for (i = 1; i &lt;= n; i++) {
                if (!lua_isnumber(L, i)) {
                  lua_pushstring(L, "incorrect argument");
                  lua_error(L);
                }
                sum += lua_tonumber(L, i);
              }
              lua_pushnumber(L, sum/n); /* 最初の戻り値 */
              lua_pushnumber(L, sum);   /* 2番目の戻り値 */
              return 2;                 /* 戻り値の数 */
            }
<

lua_checkstack                                                *lua_checkstack()*
>c
    int lua_checkstack (lua_State *L, int extra);
<
        スタックに少なくとも `extra` 個の空きスロットがあることを保証する。 もし
        スタックをそのサイズまで伸ばせなければ false を返す。 スタックがすでに
        指定された長さよりも長ければ、 わざわざスタックを縮めたりせず、何も変
        えない。

lua_close                                                          *lua_close()*
>c
    void lua_close (lua_State *L);
<
        渡されたLuaステート内のすべてのオブジェクトを破棄し (もしあればガベー
        ジコレクションメタメソッドも呼び)、 ステート内で使われていたすべての動
        的メモリを解放する。 プラットフォームによっては、 ホストプログラムが終
        了するときにすべてのリソースが自動的に解放されるため、 この関数を呼ぶ
        必要がないかもしれない。 一方、デーモンやウェブサーバのような長時間実
        行するプログラムでは、 消費リソースが増大するのを避けるために、 必要な
        くなったステートはすぐに解放する必要があるだろう。

lua_concat                                                        *lua_concat()*
>c
    void lua_concat (lua_State *L, int n);
<
        スタックトップから `n` 個の値を連結し、それらを取り除き、結果をスタック
        トップに載せる。 もし `n` が1ならは、結果はその1つの文字列である (要する
        に何もしない)。 もし `n` が0ならば、結果は空文字列である。 連結は通常の
        Luaの意味論に従って行われる (|lua-concat| を参照)。

lua_cpcall                                                        *lua_cpcall()*
>c
    int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);
<
        Cの関数 `func` を保護モードで呼ぶ。 `func` はスタックに1個の引数、 `ud` を持
        つライトユーザーデータが載った状態で開始する。 エラーが起こった場合、
        `lua_cpcall` は `lua_pcall` (|lua_pcall()| を参照)と同じエラーコードを返し、
        エラーオブジェクトをスタックトップに置く。 そうでなければ0を返し、ス
        タックは何も変えない。 `func` から返される値はすべて捨てられる。

lua_createtable                                              *lua_createtable()*
>c
    void lua_createtable (lua_State *L, int narr, int nrec);
<
        新しい空のテーブルを作り、スタックに積む。 この新しいテーブルは `narr`
        個の配列要素と `nrec` 個の非配列要素のための割り当て済み空間を持ってい
        る。 この事前割り当ては、そのテーブルがたくさんの要素を持つであろうと
        わかっている場合に役に立つ。 それ以外の場合は、関数 `lua_newtable` を使っ
        ても良い(|lua_newtable() を参照)。

lua_dump                                                            *lua_dump()*
>c
    int lua_dump (lua_State *L, lua_Writer writer, void *data);
<
        関数をバイナリチャンクとしてダンプする。 スタックトップにLuaの関数を1
        つ受け取り、1つのバイナリチャンクを生成する。 これは、再びロードされた
        とき、ダンプされたものと同等の関数を作る。 チャンクの各部を生成すると
        き、 `lua_dump` はそれらを書き込むために関数 `writer` (|lua_Writer| を参照)
        を、 `data` を与えて呼ぶ。

        戻り値は writer の最後の呼び出しが返したエラーコードである。 0はエラー
        なしを表す。

        この関数はスタックからLuaの関数を取り除かない。

lua_equal                                                          *lua_equal()*
>c
    int lua_equal (lua_State *L, int index1, int index2);
<
        受け入れ可能なインデックス `index1` と `index2` の位置にある2つの値が等し
        ければ1を返す。 そうでなければ0を返す。 どちらかのインデックスが有効で
        ないときも0を返す。 比較はLuaの `==` 演算子の意味論に従って行われる (つ
        まり、メタメソッドを呼ぶ場合がある)。

lua_error                                                          *lua_error()*
>c
    int lua_error (lua_State *L);
<
        Luaエラーを生成する。 呼ぶ前に、エラーメッセージ (実際にはどんな型の値
        でも良い) をスタックトップに置かなければならない。 この関数はロングジャ
        ンプを行うので、決して戻ってこない (|luaL_error()| を参照)。

lua_gc                                                                *lua_gc()*
>c
    int lua_gc (lua_State *L, int what, int data);
<
        Controls the garbage collector.
        ガベージコレクタを制御する。

        この関数は引数 `what` の値に応じていくつかの仕事を行う。

        - `LUA_GCSTOP`      ガベージコレクタを停止させる。
        - `LUA_GCRESTART`   ガベージコレクタを再開させる。
        - `LUA_GCCOLLECT`   フルガベージコレクションサイクルを実行する。
        - `LUA_GCCOUNT`     Luaが使っている現在のメモリ量を(キロバイトで)返す。
        - `LUA_GCCOUNTB`    Luaが使っている現在のメモリ量のバイト数を1024で割っ
                          た余りを返す。
        - `LUA_GCSTEP`      ガベージコレクションのインクリメンタルステップひと
                          つを実行する。 ステップの「サイズ」は `data` で制御す
                          る。 大きな値は大きなステップを意味するが、具体的に
                          は定まっていない。 ステップサイズを制御したければ、
                          `data` の値を実験的に調整しなければならない。 そのス
                          テップでガベージコレクションサイクルが終われば、この
                          関数は1を返す。
        - `LUA_GCSETPAUSE`  コレクタの 停止値 (|lua-gc| を参照) の新しい値とし
                          て `data` / 100を設定する。 関数は以前の停止値を返す。
                          pause.
        - `LUA_GCSETSTEPMUL`コレクタの ステップ係数 (|lua-gc| を参照) の新しい値と
                          して 引数 / 100を設定する。 関数は以前のステップ係数
                          の値を返す。

lua_getallocf                                                  *lua_getallocf()*
>c
    lua_Alloc lua_getallocf (lua_State *L, void **ud);
<
        渡されたステートのメモリアロケータ関数を返す。 `ud` が `NULL` でなければ、
        Luaは `lua_newstate` に渡されたポインタを `*ud` に格納する
        (|lua_newstate()|を参照)。

lua_getfenv                                                      *lua_getfenv()*
>c
    void lua_getfenv (lua_State *L, int index);
<
        指定したインデックスの値の環境テーブルをスタックに積む。

lua_getfield                                                    *lua_getfield()*
>c
    void lua_getfield (lua_State *L, int index, const char *k);
<
        値 `t[k]` をスタックに積む。 ただし `t` は指定した有効なインデックス `index`
        の値である。 Luaの中でと同様に、この関数は "index" イベントのメタメソッ
        ドを呼ぶ場合がある (|lua-metatable| を参照)。

lua_getglobal                                                  *lua_getglobal()*
>c
    void lua_getglobal (lua_State *L, const char *name);
<
        グローバル変数 `name` の値をスタックに積む。 これはマクロとして定義され
        ている:
>c
            #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)
<

lua_getmetatable                                            *lua_getmetatable()*
>c
    int lua_getmetatable (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値のメタテーブルをスタックに積む。
        インデックスが有効でないか、その値がメタテーブルを持っていなければ、
        この関数は0を返し、スタックには何も積まない。

lua_gettable                                                    *lua_gettable()*
>c
    void lua_gettable (lua_State *L, int index);
<
        値 `t[k]` をスタックに積む。 ただし `t` は渡された有効なインデックス `index`
        の値で、 `k` はスタックトップの値である。

        この関数はスタックからキーを (そこに結果を置く前に) 取り除く。 Luaの中
        でと同様に、この関数は "index" イベントのメタメソッドを呼ぶ場合がある
        (|lua-metatable| を参照)。

lua_gettop                                                        *lua_gettop()*
>c
    int lua_gettop (lua_State *L);
<
        スタックトップの要素のインデックスを返す。 インデックスは1から始まるの
        で、この戻り値はスタックの要素数と等しい (そしてゼロはスタックが空であ
        ることを意味する)。

lua_insert                                                        *lua_insert()*
>c
    void lua_insert (lua_State *L, int index);
<
        指定した位置より上の要素をずらして空きスペースを作り、スタックトップの
        要素をその位置に移動する。 疑似インデックスは、実際のスタック位置では
        ないため、指定できない。

lua_Integer                                                        *lua_Integer*
>c
    typedef ptrdiff_t lua_Integer;
<
        整数値を表現するための、Lua APIで使われる型。

        デフォルトでは `ptrdiff_t` である。 これは通常、マシンが「快適に」扱える
        最大の整数型である。

lua_isboolean                                                  *lua_isboolean()*
>c
    int lua_isboolean (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値がブーリアン型であれば1、そうで
        なければ0を返す。

lua_iscfunction                                              *lua_iscfunction()*
>c
    int lua_iscfunction (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値がCの関数であれば1、そうでなけれ
        ば0を返す。

lua_isfunction                                                *lua_isfunction()*
>c
    int lua_isfunction (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値が関数 (CかLuaどちらかの) であれ
        ば1、そうでなければ0を返す。

lua_islightuserdata                                      *lua_islightuserdata()*
>c
    int lua_islightuserdata (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値がライトユーザーデータであれば1、
        そうでなければ0を返す。

lua_isnil                                                          *lua_isnil()*
>c
    int lua_isnil (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値が `nil` であれば1、そうでなければ
        0を返す。

lua_isnumber                                                    *lua_isnumber()*
>c
    int lua_isnumber (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値が数値か、数値に変換できる文字列
        であれば1、そうでなければ0を返す。

lua_isstring                                                    *lua_isstring()*
>c
    int lua_isstring (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値が文字列か数値であれば1、そうで
        なければ0を返す。 (数値の場合、それは文字列に変換される)

lua_istable                                                      *lua_istable()*
>c
    int lua_istable (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値がテーブルであれば1、そうでなけ
        れば0を返す。

lua_isthread                                                    *lua_isthread()*
>c
    int lua_isthread (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値がスレッドであれば1、そうでなけ
        れば0を返す。

lua_isuserdata                                                *lua_isuserdata()*
>c
    int lua_isuserdata (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値がユーザーデータ (フルかライトど
        ちらかの) であれば1、そうでなければ0を返す。

lua_lessthan                                                    *lua_lessthan()*
>c
    int lua_lessthan (lua_State *L, int index1, int index2);
<
        受け入れ可能なインデックス `index1` の値が受け入れ可能なインデックス
        `index2` の値よりも小さければ1、そうでなければ0を返す。 どちらかのイン
        デックスが有効でない場合も0を返す。 比較はLuaの `<` 演算子の意味論に従っ
        て行われる (つまり、メタメソッドを呼ぶ場合がある)。

lua_load                                                            *lua_load()*
>c
    int lua_load (lua_State *L,
                  lua_Reader reader,
                  void *data,
                  const char *chunkname);
<
        Luaチャンクをロードする。 エラーがなければ、 `lua_load` はコンパイルした
        チャンクをLuaの関数としてスタックトップに積む。 そうでなければ、エラー
        メッセージを積む。 `lua_load` の戻り値は以下の通り:

         - `0` : エラーなし。
         - `LUA_ERRSYNTAX` : コンパイル時に構文エラーが発生。
         - `LUA_ERRMEM` : メモリ割り当てエラー。

        この関数はチャンクをロードするだけで実行しない。

        `lua_load` はチャンクがテキストかバイナリかを自動的に検出し、それに応じ
        てチャンクをロードする (プログラム `luac` を参照)。

        `lua_load` はチャンクを読み込むためにユーザが提供する `reader` 関数を使う
        (|lua_Reader| を参照)。 `data` 引数はそのリーダ関数に渡される値である。

        `chunkname` 引数はチャンクに名前を与える。 これはエラーメッセージやデバッ
        グ情報で使われる (|lua-apiDebug| を参照)。

lua_newstate                                                    *lua_newstate()*
>c
    lua_State *lua_newstate (lua_Alloc f, void *ud);
<
        新しい独立したステートを作る。 ステートを作れなければ (メモリ不足のた
        めに)、 `NULL` を返す。引数 `f` はアロケータ関数である。 Luaはこのステート
        のためのすべてのメモリ確保をこの関数を使って行う。 2番目の引数 `ud` は、
        そのアロケータに毎回渡されるポインタである。

lua_newtable                                                    *lua_newtable()*
>c
    void lua_newtable (lua_State *L);
<
        新しい空のテーブルを作ってスタックに積む。 `lua_createtable(L, 0, 0)` と
        同等である(|lua_createtable()| を参照)。

lua_newthread                                                  *lua_newthread()*
>c
    lua_State *lua_newthread (lua_State *L);
<
        新しいスレッドを作ってスタックに積み、 その新しいスレッドを表す
        `lua_State` へのポインタを返す。 この関数が返した新しいステートは元のス
        テートとすべてのグローバルオブジェクト (テーブルとか) を共有するが、独
        立した実行スタックを持つ。

        スレッドを閉じたり破棄する明示的な関数はない。 スレッドは他のLuaオブ
        ジェクト同様、ガベージコレクションの対象である。

lua_newuserdata                                              *lua_newuserdata()*
>c
    void *lua_newuserdata (lua_State *L, size_t size);
<
        この関数は指定されたサイズのメモリブロックを割り当て、 そのアドレスを
        持つ新しいフルユーザーデータをスタックに積み、 そのアドレスを返す。

                                                                    *userdata*
        ユーザーデータはLua内でCの値を表現する。 フルユーザーデータ はメモリブ
        ロックを表す。 これは (テーブルと同じように) オブジェクトである。 作成
        する必要があり、独自のメタテーブルを持つことができ、 ガベージコレクショ
        ンされるのを検出できる。 フルユーザーデータは (rawequalの下では) それ
        自身と比較したときだけ等しい。

        Luaが `gc` メタメソッドを持つフルユーザーデータを回収するとき、 Luaはメ
        タメソッドを呼び、ユーザーデータにファイナライズ済みの印を付ける。 こ
        のユーザーデータがもう一度回収されると、Luaは対応するメモリを解放する。

lua_next                                                            *lua_next()*
>c
    int lua_next (lua_State *L, int index);
<
        スタックからキーを取り出し。 指定したインデックスのテーブルからキー・
        値のペア (取り出したキーの「次」のペア) を積む。 これ以上要素がなけれ
        ば、 `lua_next` は (何も積まずに) 0を返す。

                                                         *lua-tabletraversal*
        典型的な巡回は次のようになる。
>c
               /* テーブルはスタックの `t' の位置にあるとする */
               lua_pushnil(L);  /* 最初のキー */
               while (lua_next(L, t) != 0) {
                 /* 'キー'インデックス-2、'値'はインデックス-1の位置にある */
                 printf("%s - %s\n",
                        lua_typename(L, lua_type(L, -2)),
                        lua_typename(L, lua_type(L, -1)));
                 /* '値'を除去し、'キー'は次の繰り返しのために残す */
                 lua_pop(L, 1);
               }
<
        テーブルを巡回する間、 キーが本物の文字列であるかどうか判らないなら、
        キーに対して直接 `lua_tolstring` (|lua_tolstring()| を参照)を呼んではなら
        ない。 `lua_tolstring` は指定したインデックスにある値を `変える` ため、次
        の `lua_next` の呼び出しを混乱させることを覚えておくように。

lua_Number                                                          *lua_Number*
>c
    typedef double lua_Number;
<
        Luaの数値の型。 デフォルトでは、これはdoubleであるが、 `luaconf.h` で変
        えることができる。

        コンフィギュレーションファイルを変更することで、 Luaが数値に対して他の
        型 (floatやlongなど) を使うようにできる。

lua_objlen                                                        *lua_objlen()*
>c
    size_t lua_objlen (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値の「長さ」を返す。 文字列の場合
        はその文字列の長さ、 テーブルの場合は長さ演算子 (`#`) の結果、 ユーザー
        データの場合は割り当てられたメモリブロックのサイズ、 それ以外の場合は0
        を返す。

lua_pcall                                                          *lua_pcall()*
>c
    lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
<
        関数を保護モードで呼ぶ。

        `nargs` と `nresults` は `lua_call` (|lua_call() を参照)と同じである。 もしエ
        ラーがなければ `lua_pcall` は `lua_call` とまったく同じように動作する。
        しかし、何かエラーが起きた場合は、 `lua_pcall` はそれを捕らえて、 1つ
        の値 (エラーメッセージ) をスタックに積んでエラーコードを返す。
        `lua_call` 同様、 `lua_pcall` は常に関数とその引数をスタックから取り除く。

        もし `errfunc` が0であれば、スタックに返されたエラーメッセージは正確に元
        のエラーメッセージである。 そうでなければ、 `errfunc` は エラーハンド
        ラ関数 のスタックインデックスを指定する (現在の実装では、疑似インデッ
        クスは指定できない)。 実行時エラーが起きると、エラーメッセージを引数と
        してこの関数が呼ばれ、 その戻り値が `lua_pcall` から返されるエラーメッ
        セージとなる。

        典型的には、エラーハンドラ関数は、エラーメッセージにスタックトレースの
        ようなデバッグ情報を付け加えるのに使う。 そういった情報は `lua_pcall` か
        ら戻った後にはもうスタックから除去されているため、集めることができな
        い。

        `lua_pcall` 関数は成功時は0を返し、 エラーの場合は以下のエラーコードのい
        ずれかを返す (`lua`.h で定義されている)。

        - `LUA_ERRRUN`  実行時エラー。
        - `LUA_ERRMEM`  メモリ確保エラー。 このようなエラーでは、Luaはエラーハ
                      ンドラ関数を呼ばない。
        - `LUA_ERRERR`  エラーハンドラ関数実行中のエラー。

lua_pop                                                              *lua_pop()*
>c
    void lua_pop (lua_State *L, int n);
<
        スタックから `n` 個の要素を取り除く。

lua_pushboolean                                              *lua_pushboolean()*
>c
    void lua_pushboolean (lua_State *L, int b);
<
        値 `b` のブーリアン値をスタックに積む。

lua_pushcclosure                                            *lua_pushcclosure()*
>c
    void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
<
        新しいCのクロージャをスタックに積む。

        Cの関数を作るとき、いくつかの値を関連付けて Cのクロージャ を作ることが
        できる (|lua-cclosure| を参照)。 これらの値はその関数が呼ばれたときにい
        つでもアクセスできる。 Cの関数に値を関連付けるには、 まずそれらの値を
        スタックに積む (複数の値がある場合は、最初の値を最初に積む)。 次に
        `lua_pushcclosure` を呼び、 Cの関数を作ってスタックにプッシュする。 引数
        `n` は関数に関連付ける値の数を示す。 `lua_pushcclosure` はスタックからそれ
        らの値を取り除く。

lua_pushcfunction                                          *lua_pushcfunction()*
>c
    void lua_pushcfunction (lua_State *L, lua_CFunction f);
<
        Cの関数をスタックに積む。 この関数はCの関数へのポインタを受け取り、
        `関数` 型のLua値をスタックに積む。 この値が呼ばれると、対応するCの関数が
        呼ばれる。

        Luaに登録する関数は引数と戻り値を受け渡すために、 正しい手順に従わなけ
        れば鳴らない (|lua_CFunction| を参照)。

        `lua_pushcfunction` は、マクロとして定義されている:
>c
            #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)
<

lua_pushfstring                                              *lua_pushfstring()*
>c
    const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
<
        書式化文字列をスタックに積み、この文字列を指すポインタを返す。 これはC
        の関数 `sprintf` に似ているが、いくつか重要な違いがある。

         - 結果を格納する空間を割り当てる必要がない。 結果はLuaの文字列であり、
           Luaはメモリの確保を (そしてガベージコレクションによる解放も) 自分で
           行う。
         - 変換指定子はかなり制限されている。 フラグや幅、精度は指定できない。
           変換師は単純な以下のものだけが使える:

           `%%` (文字 `%`)
           `%s` (長さ制限のないゼロ終端文字列)
           `%f` (lua_Number)
           `%p` (16進数としてのポインタ)
           `%d` (int)
           `%c` (文字としての int)

lua_pushinteger                                              *lua_pushinteger()*
>c
    void lua_pushinteger (lua_State *L, lua_Integer n);
<
        値 `n` を持つ数値をスタックに積む。

lua_pushlightuserdata                                  *lua_pushlightuserdata()*
>c
    void lua_pushlightuserdata (lua_State *L, void *p);
<
        ライトユーザーデータをスタックに積む。
                                                          *lua-lightuserdata*
        ユーザーデータはLua内でCの値を表現する。 ライトユーザーデータ はポイン
        タを表す。 それは (数値と同じように) 値である。 作成はせず、メタテーブ
        ルも持たず、(作成しないので) 回収もされない。 ライトユーザーデータは、
        同じCのアドレスを持つ「どの」ライトユーザーデータとも等しい。

lua_pushlstring                                              *lua_pushlstring()*
>c
    void lua_pushlstring (lua_State *L, const char *s, size_t len);
<
        `s` が指すサイズ `len` の文字列をスタックに積む。 Luaは与えられた文字列を
        内部的にコピーする (または再利用する) ため、 `s` が指すメモリは関数が
        戻ったあとすぐに解放あるいは再利用してよい。 文字列は埋め込まれたゼロ
        を含んでいても良い。

lua_pushnil                                                      *lua_pushnil()*
>c
    void lua_pushnil (lua_State *L);
<
        nil値をスタックに積む。

lua_pushnumber                                                *lua_pushnumber()*
>c
    void lua_pushnumber (lua_State *L, lua_Number n);
<
        値 `n` を持つ数値をスタックに積む。

lua_pushstring                                                *lua_pushstring()*
>c
    void lua_pushstring (lua_State *L, const char *s);
<
        `s` が指すゼロ終端文字列をスタックに積む。 Luaは与えられた文字列を内部的
        にコピーする (または再利用する) ため、 `s` が指すメモリを関数が戻ったあ
        とすぐに解放あるいは再利用してよい。 文字列は埋め込まれたゼロを含むこ
        とができない。 最初のゼロで終端するものと仮定される。

lua_pushthread                                                *lua_pushthread()*
>c
    int lua_pushthread (lua_State *L);
<
        `L` が表すスレッドをスタックに積む。そのスレッドがステーツのメインス
        レッドだった場合、1を返す。

lua_pushvalue                                                  *lua_pushvalue()*
>c
    void lua_pushvalue (lua_State *L, int index);
<
        指定した有効なインデックスにある要素のコピーをスタックに積む。

lua_pushvfstring                                            *lua_pushvfstring()*
>c
    const char *lua_pushvfstring (lua_State *L,
                                  const char *fmt,
                                  va_list argp);
<
        `lua_pushfstring` と同じであるが(|lua_pushfstring()| を参照)、 可変引数の
        代わりに `va_list` を渡す点が異なる。

lua_rawequal                                                    *lua_rawequal()*
>c
    int lua_rawequal (lua_State *L, int index1, int index2);
<
        受け入れ可能なインデックス `index1` と `index2` が プリミティブに等しい
        (つまりメタメソッドを呼ばない) とき1を返す。 そうでなければ0を返す。
        どちらかのインデックスが有効でないときも0を返す。

lua_rawget                                                        *lua_rawget()*
>c
    void lua_rawget (lua_State *L, int index);
<
        `lua_gettable` と同じであるが(|lua_gettable() を参照)、 生のアクセスを行
        う (つまりメタメソッドを呼ばない) 点が異なる。

lua_rawgeti                                                      *lua_rawgeti()*
>c
    void lua_rawgeti (lua_State *L, int index, int n);
<
        値 `t[n]` をスタックに積む。 ただし `t` は指定した有効なインデックス `index`
        の値である。 これは生のアクセスを行う。 つまりメタメソッドを呼ばない。

lua_rawset                                                        *lua_rawset()*
>c
    void lua_rawset (lua_State *L, int index);
<
        `lua_settable` と同じであるが(|lua_settable() を参照)、 生の代入である点
        が異なる (メタメソッドを呼ばない)。

lua_rawseti                                                      *lua_rawseti()*
>c
    void lua_rawseti (lua_State *L, int index, int n);
<
        `t[n] = v` と同じことを行う。 ただし `t` は指定した有効なインデックス
        `index` の値で、 `v` はスタックトップの値である。

        この関数は値をスタックから取り除く。 これは生の代入を行う。 つまりメタ
        メソッドを呼ばない。

lua_Reader                                                          *lua_Reader*
>c
    typedef const char * (*lua_Reader) (lua_State *L,
                                        void *data,
                                        size_t *size);
<
        `lua_load` で使うリーダー関数(|lua_load()| を参照)。 チャンクの新たなピー
        スが必要になるたびに、 `data` 引数を付けてリーダーが呼ばれる。 リーダーは
        チャンクの新たなピースを埋めたメモリブロックを指すポインタを返し、 そ
        の長さを `size` にセットしなければならない。 ブロックはリーダー関数がも
        う一度呼ばれるまで存在しなければならない。 チャンクの最後に達したこと
        を伝えるには `NULL` を返す。 リーダー関数は1以上の任意のサイズのピースを
        返すことができる。

lua_register                                                    *lua_register()*
>c
    void lua_register (lua_State *L,
                       const char *name,
                       lua_CFunction f);
<
        Cの関数 `f` をグローバル変数 `name` の新しい値としてセットする。 これはマ
        クロとして定義されている。
>c
            #define lua_register(L,n,f) \
                   (lua_pushcfunction(L, f), lua_setglobal(L, n))
<

lua_remove                                                        *lua_remove()*
>c
    void lua_remove (lua_State *L, int index);
<
        指定した有効なインデックスの要素を取り除き、 上の要素をずらして隙間を
        埋める。 疑似インデックスは、実際のスタック位置でないため、指定できな
        い。

lua_replace                                                      *lua_replace()*
>c
    void lua_replace (lua_State *L, int index);
<
        スタックトップの要素を指定した位置へ移動する。 スタックトップの値は取
        り除く。 他のどの要素もずらさない。 つまり指定した位置の値を置き換え
        る。

lua_resume                                                        *lua_resume()*
>c
    int lua_resume (lua_State *L, int narg);
<
        指定したスレッドのコルーチンを再開する。

        コルーチンを開始するためには、まず新しいスレッドを作る (`lua_newthread()`
        を参照)。 次にメイン関数と任意個の引数をスタックに積み、 `nargs` に引数
        の数を渡して。 `lua_resume` を呼ぶ。 コルーチンが中断されたり実行終了し
        たら、呼び出しから戻る。 戻ってきたとき、スタックには `lua_yield`
        (`lua_yield()` を参照)に渡された値か、本体の関数から返された値がすべて
        積まれている。 コルーチンが yieldした場合、 `lua_resume` は `LUA_YIELD` を
        返す。 コルーチンがエラーなく実行終了した場合は0を返す。エラーが起きた
        場合はエラーコードを返す (`lua_pcall()` を参照)。 エラーの場合、スタック
        は巻き戻されておらず、従ってその上でデバッグAPIを使うことができる。ス
        タックトップにエラーメッセージが置かれる。 コルーチンを再開するには、
        `lua_yield` から返される結果として渡す値だけをスタックに起き、
        `lua_resume` を呼ぶ。

lua_setallocf                                                  *lua_setallocf()*
>c
    void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
<
        指定されたステートのアロケータ関数を `f` と `ud` に変更する。

lua_setfenv                                                      *lua_setfenv()*
>c
    int lua_setfenv (lua_State *L, int index);
<
        スタックからテーブルを取り除き、指定したインデックスの値の新しい環境と
        して設定する。 指定したインデックスの値が関数、スレッド、ユーザーデー
        タのどれでもなければ、 `lua_setfenv` は0を返す。 そうでなければ1を返す。

lua_setfield                                                    *lua_setfield()*
>c
    void lua_setfield (lua_State *L, int index, const char *k);
<
        `t[k] = v` を実行する。 ただし `t` は指定した有効なインデックス `index` の値
        で、 `v` はスタックトップの値である。

        この関数は値をスタックから除去する。 Luaの中でのように、この関数は
        "newindex" イベントのメタメソッドを呼ぶ場合がある (|lua-metatable| を参
        照)。

lua_setglobal                                                  *lua_setglobal()*
>c
    void lua_setglobal (lua_State *L, const char *name);
<
        スタックから値を取り除き、それをグローバル変数 `name` の新しい値として設
        定する。 これはマクロとして定義されている。
>c
            #define lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)
<

lua_setmetatable                                            *lua_setmetatable()*
>c
    int lua_setmetatable (lua_State *L, int index);
<
        スタックからテーブルを取り除き、それを指定した受け入れ可能なインデック
        スの値の新しいメタテーブルとして設定する。

lua_settable                                                    *lua_settable()*
>c
    void lua_settable (lua_State *L, int index);
<
        `t[k] = v` を実行する。 ただし `t` は指定した有効なインデックス `index` の値
        で、 `v` はスタックトップの値で、 `k` はそのひとつ下の値である。

        この関数はキーと値の両方をスタックから取り除く。 Luaの中でのように、こ
        の関数は "newindex" イベントのメタメソッドを呼ぶ場合がある
        (|lua-metatable| を参照)。

lua_settop                                                        *lua_settop()*
>c
    void lua_settop (lua_State *L, int index);
<
        任意の受け入れ可能なインデックスまたは0を受け取り、 スタックトップをそ
        のインデックスに設定する。 新しいトップが古いものより大きければ、新し
        い要素は `nil` で埋められる。 `index` が0の場合は、スタック要素がすべて削
        除される。

lua_State                                                            *lua_State*
>c
    typedef struct lua_State lua_State;
<
        Luaインタプリタの状態全体を保持する不透明な構造体。 Luaライブラリはグ
        ローバル変数を使っていないので、完全に再入可能である。 ステートに関す
        るすべての情報はこの構造体に保持されている。

        このステートへのポインタは、 無からLuaステートを作成する `lua_newstate`
        (|lua_newstate()| を参照)を除いて、 ライブラリのすべての関数で最初の引数
        として渡さなければならない。

lua_status                                                        *lua_status()*
>c
    int lua_status (lua_State *L);
<
        スレッド `L` の状態を返す。

        通常のスレッドの状態は0である。 スレッドがエラー終了していればエラー
        コード、 スレッドが中断していれば `LUA_YIELD` を返す。

lua_toboolean                                                  *lua_toboolean()*
>c
    int lua_toboolean (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値をCのブーリアン値 (0または1) に
        変換する。 Luaでの条件判断と同様に、 `lua_toboolean` は `false` と `nil` 以
        外のすべての値に対して1を返し、 そうでなければ0を返す。 有効でないイン
        デックスを指定した場合も0を返す。 もし本当のブーリアン値だけを調べたい
        場合は、 `lua_isboolean` (|lua_isboolean() を参照) で値の型を判定すること。

lua_tocfunction                                              *lua_tocfunction()*
>c
    lua_CFunction lua_tocfunction (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値をCの関数に変換する。 この値はC
        の関数でなければならなず、それ以外では `NULL` を返す。

lua_tointeger                                                  *lua_tointeger()*
>c
    lua_Integer lua_tointeger (lua_State *L, int idx);
<
        指定した受け入れ可能なインデックスのLuaの値を符号付き整数型
        `lua_Integer` に変換する(|lua_Integer| を参照)。 このLuaの値は数値か、数値
        に変換できる文字列でなければならない (|lua-coercion| を参照)。 それ以外
        の場合、 `lua_tointeger` は0を返す。

        数値が整数でなければ、何らかの未規定な方法で整数に丸める。

lua_tolstring                                                  *lua_tolstring()*
>c
    const char *lua_tolstring (lua_State *L, int index, size_t *len);
<
        指定した受け入れ可能なインデックスのLuaの値を文字列 (const char*) に変
        換する。 もし `len` が `NULL` でなければ、 `*len` に文字列の長さも設定され
        る。 このLuaの値は文字列か数値でなければならず、 それ以外の場合、この
        関数は `NULL` を返す。 もしその値が数値であれば、 `lua_tolstring` はスタッ
        ク内のその実際の値を文字列に `変換` する (この変換はテーブル巡回中のキー
        に対して `lua_tolstring` を使ったときに `lua_next` |lua_next()|を混乱させる)。

        `lua_tolstring` はLuaステート内部の文字列を指す、完全にアラインメントさ
        れたポインタを返す。 この文字列は、その最後に必ずゼロ (`\0`) を持つ (C
        でよくやるように) が、 その途中にもゼロを含むことがある。 Luaはガベー
        ジコレクションを持っているため、 `lua_tolstring` の返したポインタが、そ
        の値がスタックから取り除かれた後も有効であり続けるという保証はない。

lua_tonumber                                                    *lua_tonumber()*
>c
    lua_Number lua_tonumber (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスにあるLuaの値を数値に変換する
        (`lua_Number` を参照)。 このLuaの値は数値か、数値に変換できる文字列でな
        ければならない (|lua-coercion| を参照)。 それ以外の場合、 `lua_tonumber` 
        は0を返す。

lua_topointer                                                  *lua_topointer()*
>c
    const void *lua_topointer (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値をCの汎用ポインタ (`void*`) に変換
        する。 この値は、ユーザーデータ、テーブル、スレッド、関数のいずれかで
        ある。 それ以外なら `lua_topointer` は `NULL` を返す。 Luaは異なるオブジェ
        クトに対しては異なるポインタを返すことを保証する。 ポインタからその元
        の値に変換する直接的な方法は無い。

        典型的には、この関数はデバッグ情報のためにだけ使われる。

lua_tostring                                                    *lua_tostring()*
>c
    const char *lua_tostring (lua_State *L, int index);
<
        `len` に `NULL` を渡して `lua_tolstring` (|lua_tolstring()| を参照)を呼ぶのと
        同じ。

lua_tothread                                                    *lua_tothread()*
>c
    lua_State *lua_tothread (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値をLuaのスレッド (`lua_State`* 
        |lua_State| で表される) に変換する。 この値はスレッドでなければならず、
        それ以外では `NULL` を返す。

lua_touserdata                                                *lua_touserdata()*
>c
    void *lua_touserdata (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値がフルユーザーデータであれば、そ
        のブロックのアドレスを返す。 ライトユーザーデータであれば、そのポイン
        タを返す。 どちらでもなければ `NULL` を返す。

lua_type                                                            *lua_type()*
>c
    int lua_type (lua_State *L, int index);
<
        指定した受け入れ可能なインデックスの値の型を返す。 有効でないインデッ
        クス (つまりその位置に要素がない) の場合は `LUA_TNONE` を返す。 `lua_type`
        が返す型は lua.h で定義されている以下の定数である。

        `LUA_TNIL`
        `LUA_TNUMBER`
        `LUA_TBOOLEAN`
        `LUA_TSTRING`
        `LUA_TTABLE`
        `LUA_TFUNCTION`
        `LUA_TUSERDATA`
        `LUA_TTHREAD`
        `LUA_TLIGHTUSERDATA`

lua_typename                                                    *lua_typename()*
>c
    const char *lua_typename  (lua_State *L, int tp);
<
        `tp` が示す型の名前を返す。 `tp` は `lua_type` が返す値のいずれかでなければ
        ならない。

lua_Writer                                                          *lua_Writer*
>c
    typedef int (*lua_Writer) (lua_State *L,
                               const void* p,
                               size_t sz,
                               void* ud);
<
        `lua_dump` (|lua_dump()| を参照)で使うライター関数。 新しいチャンクのピー
        スが生成されるたびに、 書き込みバッファ (`p`)、そのサイズ (`sz`)、 および
        `lua_dump` に渡した `data` 引数を渡して `lua_dump` がライターを呼ぶ。

        ライターはエラーコードを返す。 0はエラーなしを意味する。 それ以外の値
        はエラーを意味し、 `lua_dump` にそれ以上ライターを呼ぶのをやめさせる

lua_xmove                                                          *lua_xmove()*
>c
    void lua_xmove (lua_State *from, lua_State *to, int n);
<
        `同じ` グローバルステートの異なるスレッド間で値を交換する。

        この関数は `from` のスタックから `n` 個の値を取り出し、 それらを `to` のス
        タックに積む。

lua_yield                                                          *lua_yield()*
>c
    int lua_yield (lua_State *L, int nresults);
<
        コルーチンを中断する。

        この関数は以下のようにCの関数のreturn式でだけ呼べる。
>c
               return lua_yield (L, nresults);
<
        Cの関数がこの方法で `lua_yield` を呼ぶとコルーチンの実行は中断され、 こ
        のコルーチンを開始した `lua_resume` (|lua_resume() を参照)の呼び出しから
        戻る。 引数 `nresults`は `lua_resume` から返したいスタック上の値の数である。

                                                           *lua-stackexample*
        スタック操作の例として、もしスタックが `10 20 30 40 50*` (下から上へ;
        `*` マークが上を表す) で始まる場合:
>
               lua_pushvalue(L, 3)    --> 10 20 30 40 50 30*
               lua_pushvalue(L, -1)   --> 10 20 30 40 50 30 30*
               lua_remove(L, -3)      --> 10 20 30 40 30 30*
               lua_remove(L,  6)      --> 10 20 30 40 30*
               lua_insert(L,  1)      --> 30 10 20 30 40*
               lua_insert(L, -1)      --> 30 10 20 30 40*  (no effect)
               lua_replace(L, 2)      --> 30 40 20 30*
               lua_settop(L, -3)      --> 30 40*
               lua_settop(L,  6)      --> 30 40 nil nil nil nil*
<

==============================================================================
3.8  The Debug Interface                                       *lua-apiDebug*

Luaは組み込みのデバッグ機能を持っていない。 代わりに、そのための関数と フック
による特殊なインタフェイスを提供している。 このインタフェイスで、様々な種類の
デバッガ、プロファイラ、およびインタプリタの「内部情報」を必要とするその他の
ツールを作れるようになっている。

lua_Debug                                                            *lua_Debug*

>c
    typedef struct lua_Debug {
        int event;
        const char *name;           /* (n) */
        const char *namewhat;       /* (n) */
        const char *what;           /* (S) */
        const char *source;         /* (S) */
        int currentline;            /* (l) */
        int nups;                   /* (u) number of upvalues */
        int linedefined;            /* (S) */
        int lastlinedefined;        /* (S) */
        char short_src[LUA_IDSIZE]; /* (S) */
        /* private part */
        other fields
    } lua_Debug;
<

アクティブな関数に関する色々な情報を格納するのに使う構造体。 `lua_getstack`
(|lua_getstack() を参照)は後で使うために、この構造体の内部用メンバだけを埋める。
`lua_Debug` の他のフィールドを役に立つ情報で埋めるには、 `lua_getinfo`
(|lua_getinfo() を参照)を呼ぶ。

`lua_Debug` の各フィールドは以下のような意味を持っている:

- `source`             関数が文字列中で定義されたならば、その文字列である。 関
                     数がファイル中で定義されたならば、 `@` で始まり、その後に
                     ファイル名が続く。
- `short_src`          エラーメッセージに使う「可読」バージョンの `source`。 
- `linedefined`        関数定義の開始位置の行番号。
- `lastlinedefined`    関数定義の終了位置の行番号。 
- `what`               Luaの関数なら `"Lua"`、 Cの関数なら `"C"`、 チャンクのメイン
                     部であれば `"main"`、 関数が終端呼び出ししたならば `"tail"`。
                     最後のケースでは、Luaはこの関数について他に何の情報も持っ
                     ていない。
- `currentline`        現在実行中の行番号。 この情報が利用可能でなければ、
                     `currentline` は -1 に設定される。
- `name`               その関数に対する適当な名前。 Luaの関数はファーストクラス
                     の値であるため、固定の名前は持っていない。 複数のグローバ
                     ル変数に格納されている関数もあれば、テーブルフィールドに
                     のみ格納されているものもある。 `lua_getinfo` は、その関数が
                     どのように呼ばれたかを調べ、良さそうな名前を探す。名前が
                     見つからなければ、 `name` は `NULL` に設定される。
- `namewhat`           `name` フィールドを説明する。 `namewhat` は、どのように関数が
                     呼ばれたかによって、以下のいずれかになる。 `"global"`,
                     `"local"`, `"method"`, `"field"`, `"upvalue"`, or `""` (空文字列。
                     他に適当なものがなければこれを使う)。
- `nups`               その関数の上位値の数。

lua_gethook                                                      *lua_gethook()*
>c
    lua_Hook lua_gethook (lua_State *L);
<
        現在のフック関数を返す。

lua_gethookcount                                            *lua_gethookcount()*
>c
    int lua_gethookcount (lua_State *L);
<
        現在のフックカウントを返す。

lua_gethookmask                                              *lua_gethookmask()*
>c
    int lua_gethookmask (lua_State *L);
<
        現在のフックマスクを返す。

lua_getinfo                                                      *lua_getinfo()*
>c
    int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
<
        `lua_Debug` (|lua_Debug| を参照)の各フィールドを役に立つ情報で埋める。

        エラー (例えば `what` に不正なを指定したとか) のときは0を返す。 文字列
        `what` の各文字は、構造体 `ar` のどのフィールドを埋めるかを選択する。 これ
        は lua_Debug の定義で括弧内に書かれた文字で指示する。 `S` はフィールド
        `source`, `linedefined`, `lastlinedefined`, `what` を埋め、 `l´ はフィールド
        currentline を埋め、以下同様。 さらに、 `f` を指定すると、指定されたレ
        ベルで走っている関数をスタックに積む。

        アクティブでない (スタック中にない) 関数の情報を得るには、 それをスタッ
        クに積んで `what` を文字 `>` で始まる文字列にする。 例えば、関数 `f` が定
        義された行番号を知りたい場合は、次のように書く。
>c
               lua_Debug ar;
               /* グローバル変数 'f' を取得 */
               lua_getfield(L, LUA_GLOBALSINDEX, "f");
               lua_getinfo(L, ">S", &ar);
               printf("%d\n", ar.linedefined);

lua_getlocal                                                    *lua_getlocal()*
>c
    const char *lua_getlocal (lua_State *L, lua_Debug *ar, int n);
<
        指定したアクティベーションレコードのローカル変数についての情報を得る。
        引数 `ar` には、事前に `lua_getstack` (|lua_getstack()| を参照)を呼んで埋め
        るか、フック (|lua_Hook| を参照) に渡された引数を使うかして、有効なアク
        ティベーションレコードを与えなければならない。 インデックス `n` は調べる
        ローカル変数を指定する (1が最初の引数か最初のアクティブなローカル変数
        で、最後のアクティブなローカル変数まである)。 `lua_getlocal` はその変数
        の値をスタックに積み、その名前を返す。

        `(` (開き括弧) で始まる変数名は内部変数を表している (ループ制御変数、
        テンポラリ変数、Cの関数のローカル変数など)。

        インデックスがアクティブなローカル変数の数より大きいときは、(何も積ま
        ずに) `NULL` を返す。

lua_getstack                                                    *lua_getstack()*
>c
    int lua_getstack (lua_State *L, int level, lua_Debug *ar);
<
        インタプリタランタイムスタックに関する情報を取得する。

        この関数は `lua_Debug` (|lua_Debug| を参照)の一部を、 指定したレベルで実行
        中の関数の `アクティベーションレコード` で埋める。 レベル0は現在走ってい
        る関数で、レベル `n+1` はレベル `n` の呼び出し元の関数である。 エラーがな
        ければ `lua_getstack` は1を返す。 スタックの深さよりも大きいレベルが指定
        された場合は0を返す。

lua_getupvalue                                                *lua_getupvalue()*
>c
    const char *lua_getupvalue (lua_State *L, int funcindex, int n);
<
        クロージャの上位値に関する情報を取得する。 (Luaの関数の上位値は、その
        関数が使っている外部ローカル変数で、クロージャに取り込まれたもの。)
        `lua_getupvalue` はインデックス `n` の上位値を取得し、その値をスタックに積
        み、その名前を返す。 `funcindex` はスタック中のそのクロージャを指す。
        (上位値は関数全体に渡って有効であり、特定の順序も持たない。そのため不
        定の順序で番号付けられている。)

        インデックスが上位値の数より大きい場合は、(何も積まずに) `NULL` を返す。
        Cの関数では、どの上位値に対してもその名前に空文字列 `""` を返す。

lua_Hook                                                              *lua_Hook*
>c
    typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
<
        デバッグフック関数の型。

        フックが呼ばれたとき、 `ar` 引数の `event` フィールドに フックを起動したイ
        ベントが格納されている。 Luaはこれらのイベントを以下の定数で識別する。
        `LUA_HOOKCALL`, `LUA_HOOKRET`, `LUA_HOOKTAILRET`, `LUA_HOOKLINE`,
        `LUA_HOOKCOUNT`。 さらにlineイベントでは、フィールド `currentline` も設定
        される。 `ar` の他のフィールドを得るには、 `lua_getinfo` (|lua_getinfo()| を
        参照) を呼ぶ必要がある。returnイベントでは、event は通常の `LUA_HOOKRET`
        の他に `LUA_HOOKTAILRET` が設定される場合がある。 後者はLuaが終端呼び出
        しした関数からの復帰をシミュレートしたもので、 この場合 `lua_getinfo` は
        役に立たない。

        Luaがフックを実行している間、他のフック呼び出しは向こうになる。 従っ
        て、フック内でLuaの関数やチャンクを呼び出した場合、フックを呼ばずに実
        行される。


lua_sethook                                                      *lua_sethook()*
>c
    int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);
<
        デバッグフック関数を設定する。

        引数 `f` はフック関数を指定する。 `mask` はどのイベントでフックが呼ばれる
        かを定数 `LUA_MASKCALL`, `LUA_MASKRET`, `LUA_MASKLINE`, `LUA_MASKCOUNT` の論理
        和で指定する。 count 引数はmaskが `LUA_MASKCOUNT` を含むときだけ意味を持
        つ。 それぞれのイベントについて以下の状況でフックが呼ばれる:

         - `callフック` は関数を呼ぶときに呼ばれる。 フックは新しい関数に入った
           直後、その関数が引数を取得する前に呼ばれる。
         - `returnフック` は関数から戻るときに呼ばれる。 フックは関数から離れる
           直後に呼ばれる。 戻り値にはアクセスできない。
         - `lineフック` はインタプリタが新しい行のコードの実行を開始しようとして
           いるとき、 および同じ行内でもジャンプが行われたときに呼ばれる (この
           イベントはLuaの関数を実行している間だけ起こる)。
         - `countフック` はインタプリタが `count` 命令を実行した直後に呼ばれる (こ
           のイベントはLuaの関数を実行している間だけ起こる)。

        `mask` にゼロを設定すればフックが無効になる。

lua_setlocal                                                    *lua_setlocal()*
>c
    const char *lua_setlocal (lua_State *L, lua_Debug *ar, int n);
<
        指定したアクティベーションレコードのローカル変数の値を設定する。 引数
        `ar` および `n` は `lua_getlocal` と同じである (|lua_getlocal()| を参照)。 こ
        の関数は `lua_setlocal` はスタックトップの値をその変数に格納し、その名前
        を返す。 またその値をスタックから取り除く。

        インデックスがアクティブなローカル変数の数よりも大きければ、(何も取り
        除かずに) `NULL` を返す。

lua_setupvalue                                                *lua_setupvalue()*
>c
    const char *lua_setupvalue (lua_State *L, int funcindex, int n);
<
        クロージャの上位値の値を設定する。 引数 `funcindex` および `n` は
        `lua_getupvalue` と同じである (|lua_getupvalue()| を参照)。 この関数は
        スタックトップの値をその上位値に格納し、その名前を返す。 またその値を
        スタックから取り除く。

        インデックスが上位値の数よりも大きければ、(何も取り除かずに) `NULL` を返
        す。

                                                           *lua-debugexample*
        例として、次の関数はスタックの特定のレベルの関数のすべてのローカル関数
        と上位値の名前の一覧を表示します。
>c
               int listvars (lua_State *L, int level) {
                 lua_Debug ar;
                 int i;
                 const char *name;
                 if (lua_getstack(L, level, &ar) == 0)
                   return 0;  /* 失敗: そのようなレベルはスタックにない */
                 i = 1;
                 while ((name = lua_getlocal(L, &ar, i++)) != NULL) {
                   printf("local %d %s\n", i-1, name);
                   lua_pop(L, 1);  /* 変数の値を取り除く */
                 }
                 lua_getinfo(L, "f", &ar);  /* 関数を取得 */
                 i = 1;
                 while ((name = lua_getupvalue(L, -1, i++)) != NULL) {
                   printf("upvalue %d %s\n", i-1, name);
                   lua_pop(L, 1);  /* 上位値を取り除く */
                 }
                 return 1;
               }
<

==============================================================================
4  THE AUXILIARY LIBRARY                                            *lua-aux*

補助ライブラリ はCとLuaのインタフェイスとなるいくつかの便利な関数を提供する。
基本APIはCとLuaの対話の基本的な関数を提供するが、補助ライブラリはいくつかの共
通の作業をする高レベルな関数を提供する。

補助ライブラリのすべての関数はヘッダーファイル `lauxlib.h` に定義され、接頭語
`luaL_` が付いている。

補助ライブラリのすべての関数は基本APIの上に構築されており、そのためこのAPIでで
きないことは何も提供していない。

補助ライブラリにはCの関数の引数をチェックするための関数がいくつかある。 これら
は常に `luaL_check*` または `luaL_opt*` という名前である。 これらの関数はチェック
が妥当(satisfied?)でなかったときエラーを生成する。 エラーメッセージは引数で書
式化される ("bad argument #1" など) ため、 他のスタック値に対してこれらの関数
を使うべきではない。

==============================================================================
4.1  Functions and Types                                   *lua-auxFunctions*

補助ライブラリのすべての関数と型をアルファベット順に示す。

luaL_addchar                                                    *luaL_addchar()*
>c
    void luaL_addchar (luaL_Buffer *B, char c);
<
        文字 `c` をバッファ `B` に追加する (|luaL_Buffer| を参照)。

luaL_addlstring                                              *luaL_addlstring()*
>c
    void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);
<
        `s` が指す長さ `l` の文字列をバッファ `B` に追加する。 (|luaL_Buffer| を参照)。
        文字列は埋め込まれたゼロを含んでいても良い。

luaL_addsize                                                    *luaL_addsize()*
>c
    void luaL_addsize (luaL_Buffer *B, size_t n);
<
        バッファエリア (|luaL_prepbuffer()| を参照) に前回コピーされた長さ `n` の文
        字列をバッファ `B` に追加する。 (|luaL_Buffer| を参照)。

luaL_addstring                                                *luaL_addstring()*
>c
    void luaL_addstring (luaL_Buffer *B, const char *s);
<
        `s` が指すゼロ終端文字列をバッファ `B` に追加する (|luaL_Buffer| を参照)。
        文字列に埋め込まれたゼロを含むことはできない。

luaL_addvalue                                                  *luaL_addvalue()*
>c
    void luaL_addvalue (luaL_Buffer *B);
<
        スタックトップの値をバッファ `B` に追加する (|luaL_Buffer| を参照)。 その
        値はスタックから取り除かれる。

        これはバッファに追加する値をスタックから取る唯一の文字列バッファ用関数
        である。

luaL_argcheck                                                  *luaL_argcheck()*
>c
    void luaL_argcheck (lua_State *L,
                        int cond,
                        int narg,
                        const char *extramsg);
<
        `cond` が真であることを確認する。 もし違ったら、メッセージ
>
               bad argument #<numarg> to <func> (<extramsg>)
<
        のエラーを生成する。 ただし `func` はコールスタックから取得する。
<

luaL_argerror                                                  *luaL_argerror()*
>c
    int luaL_argerror (lua_State *L, int narg, const char *extramsg);
<
        メッセージ
>
               bad argument #<numarg> to <func> (<extramsg>)
<
        のエラーを生成する。 ただし `func` はコールスタックから取得する。
<
        この関数は決して戻らないが、 Cの関数で `return luaL_argerror( args )` と
        して使うのが慣習である。

luaL_Buffer                                                        *luaL_Buffer*
>c
    typedef struct luaL_Buffer luaL_Buffer;
<
        `文字列バッファ` の型。

        文字列バッファはCのコードでLuaの文字列片(strings piecemeal)を組み立て
        るのに使う。 これは以下のように使用する:

         - まず `luaL_Buffer` 型の変数 `b` を宣言する。
         - 次に `luaL_buffinit(L, &b)` を呼んでそれを初期化する (|luaL_buffinit()|
           を参照)。
         - そして `luaL_add*` 関数のどれかを使ってバッファに文字列片を追加する。
         - 最後に `luaL_pushresult(&b)` を呼ぶ(|luaL_pushresult()| を参照)。 これ
           は最終的な文字列をスタックトップに残す。

        通常の操作をしている間、 文字列バッファはいくつかのスタックスロットを
        使う。 従ってバッファを使っている間は、スタックトップがどこにあるか判っ
        ていると仮定できない。 バッファ操作の正しい(successive)呼び出しの間、
        整合が取れている限りはスタックを使うことができる。 つまり、バッファ操
        作を呼び出すときは、 スタックが前回バッファ操作した直後と同じ高さでな
        ければならない。 (`luaL_addvalue` |luaL_addvalue()| はこのルールの唯一の例
        外である。) `luaL_pushresult` を呼んだあと、 スタックはバッファが初期化
        される前の高さに戻り、その上に最終的な文字列が積まれる。

luaL_buffinit                                                  *luaL_buffinit()*
>c
    void luaL_buffinit (lua_State *L, luaL_Buffer *B);
<
        バッファ `B` を初期化する。 この関数はいかなる空間も割り当てない。 バッ
        ファは変数として宣言しなければならない (`luaL_Buffer` を参照)。

luaL_callmeta                                                  *luaL_callmeta()*
>c
    int luaL_callmeta (lua_State *L, int obj, const char *e);
<
        メタメソッドを呼ぶ。

        インデックス `obj` のオブジェクトがメタテーブルを持っていて、 このメタ
        テーブルがフィールド `e` を持っていれば、 この関数はこのフィールドを呼び
        出し、引数としてそのオブジェクトを渡す。 この場合、この関数は1を返し、
        呼び出しの戻り値をスタックに積む。 メタテーブルがないかメタメソッドが
        ない場合、 この関数は (スタックに何も積まずに) 0を返す。

luaL_checkany                                                  *luaL_checkany()*
>c
    void luaL_checkany (lua_State *L, int narg);
<
        関数が位置 `arg` に任意の型 (`nil` を含む) の引数を持つかチェックする。

luaL_checkint                                                  *luaL_checkint()*
>c
    int luaL_checkint (lua_State *L, int narg);
<
        関数の第 `narg` 引数が数値であるかをチェックし、 その値を `int` にキャスト
        して返す。

luaL_checkinteger                                          *luaL_checkinteger()*
>c
    lua_Integer luaL_checkinteger (lua_State *L, int narg);
<
        関数の第 `narg` 引数が数値であるかをチェックし、 その値を `lua_Integer` に
        キャストして返す(|lua_Integer| を参照)。

luaL_checklong                                                *luaL_checklong()*
>c
    long luaL_checklong (lua_State *L, int narg);
<
        関数の第 `narg` 引数が数値であるかをチェックし、 その値を `long` にキャストして返す。

luaL_checklstring                                          *luaL_checklstring()*
>c
    const char *luaL_checklstring (lua_State *L, int narg, size_t *l);
<
        関数の第 `narg` 引数が文字列であるかをチェックし、その文字列を返す。 `l`
        が `NULL` でなければ、 `*l` に文字列の長さを格納する。

luaL_checknumber                                            *luaL_checknumber()*
>c
    lua_Number luaL_checknumber (lua_State *L, int narg);
<
        関数の第 `narg` 引数が数値であるかをチェックし、 その数値を返す
        (|lua_Number| を参照)。

luaL_checkoption                                            *luaL_checkoption()*
>c
    int luaL_checkoption (lua_State *L,
                          int narg,
                          const char *def,
                          const char *const lst[]);
<
        関数の第 `narg` 引数が文字列であるかチェックし、 配列 `lst` (NULL終端でな
        ければならない) からその文字列を検索する。 `def` が `NULL` でなければ、 関
        数が第 `narg` 引数を持たないかその引数が `nil` であった場合のデフォルト値
        として使う。

        文字列が見つかった配列インデックスを返す。 引数が文字列でないか文字列
        が見つからなければエラーを発生する。

        この関数は文字列をCの列挙型に変換するのに役に立つ。 Luaのライブラリに
        おける通常の慣例では、オプションを選択するのに、数値でなく文字列を使
        う。

luaL_checkstack                                              *luaL_checkstack()*
>c
    void luaL_checkstack (lua_State *L, int sz, const char *msg);
<
        スタックサイズを `top + sz` 個の要素に伸ばす。 スタックがそのサイズに伸
        ばせなければエラーを発生する。 `msg` はそのエラーメッセージに入れる追加
        の文字列である。

luaL_checkstring                                            *luaL_checkstring()*
>c
    const char *luaL_checkstring (lua_State *L, int narg);
<
        関数の第 `narg` 引数が文字列であるかチェックし、その文字列を返す。

luaL_checktype                                                *luaL_checktype()*
>c
    void luaL_checktype (lua_State *L, int narg, int t);
<
        関数の第 `narg` 引数が型 `t` であるかチェックする(|lua_type()| を参照)。

luaL_checkudata                                              *luaL_checkudata()*
>c
    void *luaL_checkudata (lua_State *L, int narg, const char *tname);
<
        関数の第 `narg` 引数が型 `tname` のユーザーデータであるかチェックする
        (|luaL_newmetatable()| を参照)。

luaL_dofile                                                      *luaL_dofile()*
>c
    int luaL_dofile (lua_State *L, const char *filename);
<
        指定されたファイルを読み込んで実行する。これはマクロとして定義されてい
        る:
>c
               (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
<
        エラーがあれば1を返し、そうでなければ0を返す。

luaL_dostring                                                  *luaL_dostring()*
>c
    int luaL_dostring (lua_State *L, const char *str);
<
        指定された文字列を読み込んで実行する。これはマクロとして定義されている:
>c
               (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
<
        エラーがあれば1を返し、そうでなければ0を返す。

luaL_error                                                        *luaL_error()*
>c
    int luaL_error (lua_State *L, const char *fmt, ...);
<
        エラーを発生させる。 エラーメッセージの書式は `fmt` と追加の引数で与えら
        れる。 これは `lua_pushfstring` (|lua_pushfstring()| を参照)のと同じルール
        に従う。 また、メッセージの最初にエラーが発生したファイル名と行番号を、
        それらの情報が利用可能ならば、追加する。

        この関数は決して戻らないが、 Cの関数で `return luaL_error ( args )` のよ
        うに使うのが慣例である。

luaL_getmetafield                                          *luaL_getmetafield()*
>c
    int luaL_getmetafield (lua_State *L, int obj, const char *e);
<
        インデックス `obj` のオブジェクトのメタテーブルのフィールド `e` をスタック
        に積む。 そのオブジェクトがメタテーブルを持っていないか、メタテーブル
        がそのフィールドを持っていなければ 0 を返して何も積まない。

luaL_getmetatable                                          *luaL_getmetatable()*
>c
    void luaL_getmetatable (lua_State *L, const char *tname);
<
        レジストリの名前 `tname` に関連付けられたメタテーブルをスタックに積む
        (|luaL_newmetatable()| を参照)。

luaL_gsub                                                          *luaL_gsub()*
>c
    const char *luaL_gsub (lua_State *L,
                           const char *s,
                           const char *p,
                           const char *r);
<
        文字列 `s` 中の文字列 `p` をすべて文字列 `r` で置換したコピーを作る。 その結
        果の文字列をスタックに積み、それを返す。

luaL_loadbuffer                                              *luaL_loadbuffer()*
>c
    int luaL_loadbuffer (lua_State *L,
                         const char *buff,
                         size_t sz,
                         const char *name);
<
        Luaのチャンクとしてバッファをロードする。 この関数は `lua_load`
        (|lua_load()| を参照)を使って `buff` が指すサイズ `sz` のバッファに格納されて
        いるチャンクをロードする。

        この関数は `lua_load` と同じ結果を返す。 `name` はデバッグ情報やエラーメッ
        セージで使うチャンク名である。

luaL_loadfile                                                  *luaL_loadfile()*
>c
    int luaL_loadfile (lua_State *L, const char *filename);
<
        Luaのチャンクとしてファイルをロードする。 この関数は `lua_load`
        (|lua_load()| を参照)を使って名前 `filename` のファイルに格納されているチャ
        ンクをロードする。 `filename` が `NULL` の場合は標準入力から読み込む。 ファ
        イルが `#` で始まっていたら、その最初の行を無視する。

        この関数は `lua_load` と同じ結果を返すが、 追加のエラーコードとしてファ
        イルを開けなかったり読めなかった場合は `LUA_ERRFILE` を返す。

        `lua_load` と同じ様に、この関数はチャンクをロードするだけで、実行しない。

luaL_loadstring                                              *luaL_loadstring()*
>c
    int luaL_loadstring (lua_State *L, const char *s);
<
        Luaのチャンクとして文字列をロードする。 この関数は `lua_load`
        (|lua_load()| を参照)を使ってゼロ終端文字列 `s` に格納されているチャンクを
        ロードする。

        この関数は `lua_load` と同じ結果を返す。

        `lua_load` と同じ様に、この関数はチャンクをロードするだけで、実行しない。

luaL_newmetatable                                          *luaL_newmetatable()*
>c
    int luaL_newmetatable (lua_State *L, const char *tname);
<
        レジストリにキー `tname` がすでにあれば 0 を返す。 そうでなければ、ユー
        ザーデータのメタテーブルとして使う新しいテーブルを作り、 それをレジス
        トリにキー `tname` と共に追加して 1 を返す。

        どちらの場合もレジストリの `tname` に関連付けられた最終的な値をスタック
        に積む。

luaL_newstate                                                  *luaL_newstate()*
>c
    lua_State *luaL_newstate (void);
<
        標準のCの `realloc` 関数をベースにしたアロケータ関数を使って
        `lua_newstate` (|lua_newstate()| を参照)を呼び、新しいLuaステートを作成す
        る。 また、致命的エラーの場合に標準エラー出力にエラーメッセージを出力
        するパニック関数 (|lua_atpanic()| を参照) を設定する。

        新しいステートを返す。 メモリ確保エラーの場合は `NULL` を返す。

luaL_openlibs                                                  *luaL_openlibs()*
>c
    void luaL_openlibs (lua_State *L);
<
        指定したステートにすべての標準Luaライブラリを開く。各個のライブラリを
        開く方法の詳細は |lua-openlibs| を参照。

luaL_optint                                                      *luaL_optint()*
>c
    int luaL_optint (lua_State *L, int narg, int d);
<
        関数の第 `narg` 引数が数値であれば、その数値を `int` にキャストして返す。
        その引数が存在しないか `nil` であれば、 `d` を返す。 さもなくばエラーを発
        生する。

luaL_optinteger                                              *luaL_optinteger()*
>c
    lua_Integer luaL_optinteger (lua_State *L,
                                 int narg,
                                 lua_Integer d);
<
        関数の第 `narg` 引数が数値であれば、 その数値を `lua_Integer`
        (|lua_Integer| を参照) にキャストして返す。 その引数が存在しないか `nil` 
        であれば、 `d` を返す。 さもなくばエラーを発生する。

luaL_optlong                                                    *luaL_optlong()*
>c
    long luaL_optlong (lua_State *L, int narg, long d);
<
        関数の第 `narg` 引数が数値であれば、その数値を `long` にキャストして返す。
        その引数が存在しないか `nil` であれば、 `d` を返す。 さもなくばエラーを発
        生する。

luaL_optlstring                                              *luaL_optlstring()*
>c
    const char *luaL_optlstring (lua_State *L,
                                 int narg,
                                 const char *d,
                                 size_t *l);
<
        関数の第 `narg` 引数が文字列であれば、その文字列を返す。 引数が存在しな
        いか `nil` であれば、 `d` を返す。 さもなくばエラーを発生する。

        `l` が `NULL` でなければ、結果の長さを `*l` に格納する。

luaL_optnumber                                                *luaL_optnumber()*
>c
    lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d);
<
        関数の第 `narg` 引数が数値であれば、その数値を返す。 その引数が存在しな
        いか `nil` であれば、 `d` を返す。 さもなくばエラーを発生する。

luaL_optstring                                                *luaL_optstring()*
>c
    const char *luaL_optstring (lua_State *L,
                                int narg,
                                const char *d);
<
        関数の第 `narg` 引数が文字列であれば、その文字列を返す。 その引数が存在
        しないか `nil` であれば、 `d` を返す。 さもなくばエラーを発生する。

luaL_prepbuffer                                              *luaL_prepbuffer()*
>c
    char *luaL_prepbuffer (luaL_Buffer *B);
<
        バッファ `B` に追加するための文字列を格納できる、 サイズ `LUAL_BUFFERSIZE`
        の領域のアドレスを返す (|luaL_Buffer| を参照)。 文字列をこの領域に格納し
        たあと、文字列のサイズを渡して `luaL_addsize` (|luaL_addsize()| を参照)を
        呼び、実際にバッファに追加しなければならない。

luaL_pushresult                                              *luaL_pushresult()*
>c
    void luaL_pushresult (luaL_Buffer *B);
<
        スタックトップに最終的な文字列を残してバッファ `B` の使用を終える。

luaL_ref                                                            *luaL_ref()*
>c
    int luaL_ref (lua_State *L, int t);
<
        インデックス `t` のテーブルにスタックトップのオブジェクトに対する
        `リファレンス` を作成し、それを返す
        (そしてオブジェクトをスタックから取り除く)。

        リファレンスは一意な整数のキーである。 テーブル `t` に整数キーを手動で追
        加しなければ、 `luaL_ref` は返すキーの一意性を保証する。
        `lua_rawgeti(L, t, r)` (|lua_rawgeti()| を参照)を呼ぶと、リファレンス `r` が
        参照するオブジェクトを取得できる。 `luaL_unref` (|luaL_unref()| を参照)は
        リファレンスとそれに関連付けられたオブジェクトを解放する。

        スタックトップのオブジェクトが `nil` の場合、 `luaL_ref` は定数 `LUA_REFNIL`
        を返す。 定数 `LUA_NOREF` は `luaL_ref` が返すいかなるリファレンスとも異な
        ることが保証されている。

luaL_Reg                                                              *luaL_Reg*
>c
    typedef struct luaL_Reg {
        const char *name;
        lua_CFunction func;
    } luaL_Reg;
<
        `luaL_register` (|luaL_register()| を参照)が登録する関数の配列の型。 `name`
        は関数の名前で、 `func` は関数へのポインタである。 `luaL_Reg` の配列は 
        `name` と `func` が共に `NULL` である番兵エントリで終わらなければならない。

luaL_register                                                  *luaL_register()*
>c
    void luaL_register (lua_State *L,
                        const char *libname,
                        const luaL_Reg *l);
<
        ライブラリを開く。

        `libname` に `NULL` を渡して呼ぶと、 単純にリスト `l` (|luaL_Reg| を参照) の関
        数をすべてスタックトップのテーブルに登録する。

        `libname` が `NULL` でなければ、 新しいテーブル `t` を作成し、 それをグロー
        バル変数 `libname` の値として設定し、 `package.loaded[libname]` の値として
        設定し、 そしてリスト `l` の関数をすべてそこに登録する。 もし
        `package.loaded[libname]` か変数 `libname` にテーブルが存在すれば、 新しい
        テーブルを作る代わりにそれを再利用する。

        いずれの場合も、この関数はスタックトップにそのテーブルを置く。

luaL_typename                                                  *luaL_typename()*
>c
    const char *luaL_typename (lua_State *L, int idx);
<
        インデックス `idx` の値の型の名前を返す。

luaL_typerror                                                  *luaL_typerror()*
>c
    int luaL_typerror (lua_State *L, int narg, const char *tname);
<
        Generates an error with a message like the following:

          `location`  `: bad argument`  `narg`  `to`  `'func'`  `(`  `tname`
          `expected, got`  `rt`  `)`

        のようなメッセージのエラーを生成する。 ただし `location` は `luaL_where`
        (|luaL_where()| を参照)によって生成されたもので、 `function` は現在の関数
        の名前、 and `rt`は実引数の型名である。

luaL_unref                                                        *luaL_unref()*
>c
    void luaL_unref (lua_State *L, int t, int ref);
<
        インデックス `t` のテーブルからリファレンス `ref` を解放する (|luaL_ref())|
        を参照)。 エントリがテーブルから取り除かれるので、参照されていたオブ
        ジェクトは回収され得る。 リファレンス `ref` も再利用するために解放される。

        `ref` が `LUA_NOREF` または `LUA_REFNIL` の場合、 `luaL_unref` は何もしない。

luaL_where                                                        *luaL_where()*
>c
    void luaL_where (lua_State *L, int lvl);
<
        コールスタックのレベル `lvl` の制御の現在位置を識別する文字列をスタック
        に積む。 典型的にこの文字列は `<chunkname>:<currentline>:` のような書式
        になっている。 レベル0は実行中の関数、 レベル1は実行中の関数の呼び出し
        元の関数、 以下同様である。

        この関数はエラーメッセージの接頭辞を構築するために使う。

==============================================================================
5  標準ライブラリ                                                   *lua-lib*

Lua標準ライブラリは、CのAPIを使って直接実装された便利な関数を提供する。 いくつ
かは言語の本質的なサービスを提供するものであり (例えば `type` や `getmetatable`)、
残りは「外部の」サービスへのアクセスを提供するものである (例えば I/O)。 また、
Lua自身で実装可能であるが、便利さやパフォーマンス要求のためにCで実装されたもの
もある (例えば `sort`)。

すべてのライブラリは公開されているCのAPIを使って実装されており、独立したCのモ
ジュールで提供されている。 現在、Luaには以下の標準ライブラリがある。

- 基本ライブラリ
- パッケージライブラリ
- 文字列操作
- テーブル操作
- 数学関数 (sin、logなど)
- 入出力
- OS機能
- デバッグ機能

基本ライブラリとパッケージライブラリ以外は、 それぞれのライブラリが、 グローバ
ルテーブルのフィールドか、そのオブジェクトのメソッドとして、そのすべての関数を
提供している。

                                                               *lua-openlibs*
これらのライブラリを使うには、Cのホストプログラムで すべての標準ライブラリを開
く `luaL_openlibs` を呼ばなければならない(|luaL_openlibs()| を参照)。 代わりに、
`luaopen_base` (基本ライブラリ用)、 `luaopen_package` (パッケージライブラリ用)、
`luaopen_string` (文字列ライブラリ用)、 `luaopen_table` (テーブルライブラリ用)、
`luaopen_math` (数学ライブラリ用)、 `luaopen_io` (I/OライブラリとOSライブラリ用)、
`luaopen_debug` (デバッグライブラリ用) を呼んで個別に開くこともできる。 これらは
`lualib.h` に定義されているが、 直接呼ぶべきではなく、他のLuaのC関数と同様に
---- 例えば `lua_call` (|lua_call()| を参照)を使って ---- 呼ばなければならない。

==============================================================================
5.1  基本関数                                                  *lua-lib-core*

基本ライブラリはLuaへのコアな機能を提供する。 アプリケーションにこのライブラリ
を含めない場合は、その機能を提供する代わりの実装を用意する必要があるか慎重に調
べるべきである。

assert({v} [, {message}])                               *assert()*
    引数 `v` が偽 (すなわち `nil` または `false`) であればエラーを発生させる。 そう
    でなければ、そのすべての引数を返す。 `message` はエラーメッセージを指定する。
    省略された場合は "assertion failed!" である。

collectgarbage({opt} [, {arg}])                         *collectgarbage()*
        この関数はガベージコレクタへの汎用インタフェイスである。 最初の引数
        {opt} によって異なる機能を実行する。

        `"stop"`       ガベージコレクタを停止する。
        `"restart"`    ガベージコレクタを再開する。
        `"collect"`    フルガベージコレクションサイクルを実行する。
        `"count"`      Luaが使っているメモリの合計を(キロバイトで)返す。
        `"step"`       ガベージコレクションステップひとつを実行する。 ステップ
                     の「サイズ」は {arg} で制御する。 大きな値は大きなステッ
                     プを意味するが、具体的には定まっていない。 ステップサイズ
                     を制御したければ、 {arg} の値を実験的に調整しなければなら
                     ない。 このステップでコレクションサイクルが終わった場合は
                     `true` を返す。
        `"setpause"`   コレクタの停止値 (|lua-gc| を参照) の新しい値を {arg} /100
                     に設定する。
        `"setstepmul"` コレクタの `ステップ係数` の新しい値を {arg} /100に設定す
                     る (|lua-gc| を参照)。

dofile({filename})                                      *dofile()*
        ファイルを開き、その内容をLuaチャンクとして実行する。 引数が指定されな
        ければ、標準入力 (`stdin`) から読み取って実行する。 `dofile`はチャンクから
        返されたすべての値をそのまま返す。 エラーが起きた場合は、呼び出し側に
        伝搬される (つまり `dofile` は保護モードで動くのではない)。

error({message} [, {level}])                            *error()*
        最後に保護された関数呼び出しを終了し、 `message` をエラーメッセージとし
        て返す。 関数 {error} は戻らない。

        通常、 {error} はメッセージの先頭にエラーの位置に関する何らかの情報を
        追加する。 {level} 引数は、エラーメッセージがエラー位置をどのように得
        るかを指定する。 レベル1では (デフォルト)、 {error} 関数を呼んだ場所が
        エラー位置である。 レベル2は {error} を呼んだ関数を呼んだ位置を指す。
        以下同様である。 レベル0を渡すとメッセージにエラー位置情報を追加しない。

_G                                                      *_G*
        グローバル環境を保持するグローバル変数である (関数ではない)。 つまり、
        `_G._G = _G` である。 Lua自身はこの変数を使用しないので、この値を変更し
        ても環境には何の影響もなく、逆もまた同じである (環境を変えるには
        `setfenv` を使う)。

getfenv({f})                                            *getfenv()*
        関数の現在の環境を返す。 {f} はLuaの関数か、関数のスタックレベルを示す
        数値である。 レベル1は `getfenv` を呼んだ関数である。 もし与えられた関数
        がLuaの関数でなかったり、 {f} が0の場合は、 `getfenv` はグローバル環境を
        返す。 {f} のデフォルト値は1である。

getmetatable({object})                                  *getmetatable()*
        もし {object} がメタテーブルを持っていなければ `nil` を返す。 もしobject
        のメタテーブルが `"__metatable"` フィールドを持っていれば、その値を返す。
        そうでなければobjectのメタテーブルを返す。

ipairs({t})                                             *ipairs()*
        3つの値、イテレータ (|iterator|) 関数、テーブル {t}、および0を返す。

               `for i,v in ipairs(t) do`  `body`  `end`

        は (`1,t[1]`)、(`2,t[2]`)、…のペアを、最初に値にnilが現れるまで繰り返す。

load({func} [, {chunkname}])                            *load()*
        そのピースを取得する関数 {func} を使ってチャンクをロードする。 {func}
        は前回の戻り値と連結する文字列を返さなければならない。 `nil` を返す (ま
        たは戻り値なし) とチャンクの終わりを知らせる。

        エラーがなければ、コンパイルされたチャンクが関数として返され、 そうで
        なければ `nil` とエラーメッセージが返される。 返された関数の環境はグロー
        バル環境である。

        {chunkname} はエラーメッセージやデバッグ情報のためのチャンク名を指定す
        る。

loadfile([{filename}])                                  *loadfile()*
        `load` (|load()| を参照) と同じであるが、 ファイル {filename} からチャンク
        を読み込む。 ファイル名を与えなければ標準入力から読み込む。

loadstring({string} [, {chunkname}])                    *loadstring()*
        `load` (|load()| を参照) と同じであるが、 指定した文字列からチャンクを読み
        込む。

        与えられた文字列をロードして実行するには、以下の慣用句を使う。
>lua
               assert(loadstring(s))()
<

next({table} [, {index}])                               *next()*
        テーブルの全フィールドを巡回するための関数である。 最初の引数はテーブ
        ルを、二番目の引数はこのテーブルのインデックスを渡す。 `next` はテーブル
        内の次のインデックスと、その値を返す。 二番目の引数に `nil` を渡すと、初
        期インデックスとその値が返される。 最後のインデックスで呼び出すか、空
        のテーブルに対して `nil` で呼び出すと、 `next` は `nil` を返す。 二番目の引
        数が省略された場合は `nil` と解釈される。 特に、 `next(t)` を使うとテーブ
        ルが空かどうか調べることができる。

        Luaにはフィールドの宣言がない。 テーブル内にフィールドが存在しないの
        と、 `nil` 値が格納されたフィールドには、何の違いも無い。 ゆえに、 `next`
        は `nil` でない値を持つフィールドのみを考慮する。 インデックスが列挙され
        る順番は、数値のインデックスに対しても、不定である (数値順にテーブルを
        巡回するには、数値用の `for` 文や |ipairs()| 関数を使う)。

        テーブルの巡回中に、もし存在していないフィールドに新たに値が割り当てら
        れたら、 `next` の動作は `未定義` である。 しかし既存のフィールドは変更し
        てもよい。 特に、既存のフィールドを消去するのは構わない。

pairs({t})                                              *pairs()*
        3つの値、 |next()| 関数、テーブル {t}、 `nil` を返す。

               `for k,v in pairs(t) do`  `body`  `end`

        はテーブル {t} のすべてのキー・値ペアについて繰り返す。

pcall({f}, {arg1}, {...})                               *pcall()*
        `保護モード` で、与えられた引数で {f} を呼び出す。 つまり {f} の内部で発
        生したエラーは伝搬されず、 代わりに `pcall` がエラーを捕らえ、ステータス
        コードを返す。 最初の引数はステータスコード (ブーリアン型) で、エラー
        なしに呼び出しが成功したときは真を返す。 その場合、 {f} の戻り値もすべ
        て、最初の戻り値に続いて返される。 エラーが起こった場合、 `pcall` は
        `false` とエラーメッセージを返す。

print({...})                                            *print()*
        引数をいくつでも取ることができ、それらの値を `tostring` |tostring()| で文
        字列に変換してから標準出力 (stdout) に表示する。 `print` は書式化出力を
        意図したものではなく、 典型的にはデバッグのために、値を表示する簡単な
        方法として用意されているだけである。 書式化出力には `string.format`
        (|string.format()| を参照) を使う。

rawequal({v1}, {v2})                                    *rawequal()*
        メタメソッドを呼ぶことなしに {v1} と {v2} が等しいかどうか調べる。 ブー
        リアンを返す。

rawget({table}, {index})                                *rawget()*
        メタメソッドを呼ぶことなしに `table[index]` の本当の値を得る。 {table}
        はテーブルでなければならない。 {index} は `nil` 以外のどんな値でも良い。

rawset({table}, {index}, {value})                       *rawset()*
        メタメソッドを呼ぶことなしに `table[index]` に {value} をセットする。
        {table} はテーブルでなければならない。 {index} は `nil` 以外のどんな値で
        も良い。 {value} はどんなLuaの値でも良い。

        この関数は {table} を返す。

select({index}, {...})                                  *select()*
        {index} が数値であれば、 {index} 番目以降の引数をすべて返す。 そうでな
        ければ、 {index} は文字列 `"#"` でなければならない。 この場合 `select` は
        受け取った余分の引数の合計数を返す。

setfenv({f}, {table})                                   *setfenv()*
        指定された関数で使われる環境を変更する。 {f} はLuaの関数か、関数のス
        タックレベルを指定する数値である。 レベル1は `setfenv` を呼び出した関数
        を示す。 `setfenv` は与えられた関数を返す。

        特殊なケースとして、 {f} に0が与えられると、 `setfenv` は走行中のスレッ
        ドの環境を変える。 この場合、 `setfenv` は何も返さない。

setmetatable({table}, {metatable})                      *setmetatable()*
        {table} のメタテーブルを変更する (Luaから他の型のメタテーブルを変更す
        ることはできない。Cからのみ可能である)。 もし {metatable} が `nil` であ
        れば、 {table} のメタテーブルは除去される。 元のメタテーブルが
        `"__metatable"` フィールドを持っていると、エラーを発する。

        この関数は {table} を返す。

tonumber({e} [, {base}])                                *tonumber()*
        引数を数値に変換しようとする。 もし引数がすでに数値だったり、数値に変
        換可能な文字列であれば、 `tonumber` は数値を返す。 そうでなければ `nil` を
        返す。

        省略可能な引数は数値を解釈する際の基数を指定する。 基数は2から36の整数
        を指定できる。 10より大きい基数では、 `A` が10を表し、 `B` が11を表し、 以
        下同様に続き、 `Z` が35を表す (大文字でも小文字でも良い)。 基数が10 (デ
        フォルト) の場合 は、数値に小数部や指数部を付けることができる (2.1 を
        参照)(|lua-lexical| を参照)。 他の基数では、符号なしの整数のみを受け付け
        る。

tostring({e})                                           *tostring()*
        任意の型の引数を受け取り、理解しやすい形式の文字列に変換する。 数値が
        変換される方法を完全にコントロールする場合は `string.format`
        (|string.format()| を参照)を使う。

                                                        *__tostring*
        もし {e} のメタテーブルが `"__tostring"` フィールドを持っていたら、 {e}
        を引数に、その関連付けられた値が呼び出され、その戻り値が結果として使わ
        れる。

type({v})                                               *lua-type()*
        値の型を文字列で返す。 この関数が返す値は以下のいずれかである。

            `"nil"` (という文字列。 `nil` 値ではなく。)
            `"number"`
            `"string"`
            `"boolean"`
            `"table"`
            `"function"`
            `"thread"`
            `"userdata"`

unpack({list} [, {i} [, {j}]])                          *unpack()*
        与えられたテーブルの要素を返す。 この関数は、以下のコードには固定の要
        素数しか書けないことを除いて、以下のコードと等価である。
>lua
          return list[i], list[i+1], ..., list[j]
<
        デフォルトでは、 {i} は1で {j} は長さ演算子 (|lua-length| を参照) 定義さ
        れているリストの長さである。

_VERSION                                                *_VERSION*
        現在のインタプリタのバージョン文字列を保持しているグローバル変数 (関数
        ではない)。 この変数の現在の内容は `"Lua 5.1"` である。

xpcall({f}, {err})                                      *xpcall()*
        この関数は `pcall` (|pcall()| を参照)に似ているが、エラーハンドラを指定で
        きる点が異なる。

        `xpcall` は保護モードで {f} を呼び出し、 {err} をエラーハンドラとして使
        う。 {f} の内部で発生したエラーは伝搬されない。 代わりに、 `xpcall` がエ
        ラーを捕らえ、エラーオブジェクトを引数に {err} を呼ぶ。 最初の戻り値は
        ステータスコード (ブーリアン型) で、 エラーが起きなかった場合は `true`
        を返す。 その場合、最初の戻り値に続いて {f} の戻り値もすべて返される。
        エラーが起きた場合、 `xpcall` は `false` と {err} の戻り値を返す。

==============================================================================
5.2  コルーチン操作                             *lua-lib-coroutine*

コルーチン関連の操作は基本ライブラリのサブライブラリであり、テーブル `coroutine`
内に置かれている。 コルーチンに関する一般的な説明は |lua-coroutine| を参照。

coroutine.create({f})                                       *coroutine.create()*
        {f} を本体とする新しいコルーチンを作る。 {f} はLuaの関数でなければなら
        ない。 `"thread"` 型の新しいコルーチンオブジェクトを返す。

coroutine.resume({co} [, {val1}, {...}])                    *coroutine.resume()*
        コルーチン {co} の実行を開始/再開する。 コルーチンを最初にresumeしたと
        き、その本体の実行が開始される。 値 {val1}, {...} は本体の関数に引数と
        して渡される。 コルーチンが中断されていた場合、 `resume` はそれを再開し、
        `yield` からの戻り値として {val1}, {...} が渡される。

        コルーチンがエラー無く実行されれば、 `resume` は `true` に加えて `yield` に
        渡された値 (コルーチンが中断された場合)、 もしくは本体の関数から返され
        た値 (コルーチンが終了した場合) を返す。 エラーが起きたら、 `resume` は
        `false` とエラーメッセージを返す。

coroutine.running()                                        *coroutine.running()*
        走行中のコルーチンを返す。 メインスレッドで呼ばれた場合は `nil` を返す。

coroutine.status({co})                                      *coroutine.status()*
        コルーチン {co} の状態を文字列で返す。

        `"running"` ... コルーチンは走行中。 `"suspended"` ... コルーチンは `yield`
        の呼び出しで中断されているが、まだ実行中である。 `"normal"` ... コルーチ
        ンはアクティブであるが走行中でない(つまり他のコルーチンを `resume` して
        いる)。 `"dead"` ... コルーチンの本体の関数が終了したか、エラーで停止し
        た。

coroutine.wrap({f})                                           *coroutine.wrap()*
        {f} を本体とする新しいコルーチンを作成する。 {f} はLuaの関数でなければ
        ならない。 `coroutine.wrap` は、呼ばれるたびにコルーチンを再開する関数を
        返す。 関数に渡された引数は `resume` に余分に渡される引数と同じ動作をし、
        戻り値は `resume` から最初のブーリアンを除いた値と同じである。 もしエラー
        が起きた場合、エラーは伝搬する。

coroutine.yield({...})                                       *coroutine.yield()*
        呼ばれたコルーチンの実行を中断する。 コルーチンは、Cの関数やメタメソッ
        ド、イテレータ(|iterator|)を中断することはできない。 `yield` に渡された引
        数は `resume` から追加の戻り値として返される。

==============================================================================
5.3 モジュール                                                *lua-modules*

Luaでモジュールを構築したりロードしたりする基本的な機能を提供する。 2つの関数
`require` および `module` (|module()| を |require()| を参照)はグローバル環境に直接エク
スポートされる。 それ以外はすべてテーブル `package` にエクスポートされる。

module({name} [, {...}])                                *module()*
        モジュールを作成する。 `package.loaded[name]` にテーブルがあれば、 この
        テーブルがモジュールである。 そうでなければ、指定した名前のグローバル
        なテーブル `t` があれば、 このテーブルがモジュールである。 そうでなけれ
        ば、新しいテーブル `t` を作成し、 グローバル変数 {name} の値と
        `package.loaded[name]` の値にそれを設定する。 またこの関数は指定された
        名前で `t._NAME` を、 モジュール (`t` それ自身) で `t._M` を、 パッケージ名
        (完全なモジュール名から最後の部分を除いたもの、下記参照) で
        `t._PACKAGE` を初期化する。 最後に、 `module` は現在の関数の新しい環境およ
        び `package.loaded[name]` の新しい値として `t` を設定する。 従って
        |require()| は `t` を返す。

        もし {name} が複合名 (つまり、ドットで各部が区切られたもの) であれば、
        `module` はそれぞれの部分についてテーブルを作る (または、すでに存在すれ
        ば再利用する)。 例えば、 {name} が `a.b.c` の場合、 `module` はグローバル
        変数 `a` のフィールド `b` のフィールド `c` にモジュールテーブルを格納する。

        この関数はモジュール名の後に省略可能な `オプション` を渡すことができる。
        この各オプションはモジュール全体に適用される関数である。

require({modname})                                      *require()*
        指定したモジュールをロードする。 この関数は {modname} がすでにロードさ
        れているかどうかを決定するために まずテーブル `package.loaded` を探す。
        もしすでにロードされていれば、 `require` は `package.loaded[modname]` に格
        納されている値を返す。 そうでなければ、モジュールの `ローダ` を探す。

        ローダを探すために、 `require` はまず `package.preload[modname]` を問い合
        わせる。 もしそこに値があれば、この値 (関数であるべきである) がローダ
        である。 そうでなければ、 `require` は `package.path` に格納されているパス
        を使う Luaのローダを探す。 それも失敗したら、 `package.cpath` に格納され
        ているパスを使うCのローダを探す。 それもまた失敗したら、オールインワン
        ローダ (下記参照) を試す。

        Cのライブラリをロードする場合、 `require` はまずアプリケーションをそのラ
        イブラリとリンクするためのダイナミックリンク機能を使う。 次にこのライ
        ブラリ内からローダとして使うためのCの関数を探す。 このCの関数は
        `"luaopen_"` にモジュール名を付けた名前であるが、 ドットはアンダースコア
        に置換する。 さらに、モジュール名にハイフンが含まれていれば、 その最初
        のハイフンまでの接頭辞は (ハイフンも含めて) 取り除かれる。 例えば、モ
        ジュール名が `a.v1-b.c` の場合、関数名は `luaopen_b_c` となる。

        `require` がLuaのライブラリにもCのライブラリにもモジュールを見つけられな
        ければ、 `オールインワンローダ` を呼ぶ。 このローダはCのパスを見て、指定
        したモジュールのルート名に対するライブラリを探す。 例えば `a.b.c` が要求
        された場合、 `a` というCのライブラリを探す。 もし見つかれば、そのサブモ
        ジュールに対するオープン関数をその中から探す。 先の例でいうと、
        `luaopen_a_b_c` となる。 この機能により、いくつものCのサブモジュールをひ
        とつのライブラリに納めることができる。 その場合でも各サブモジュールは、
        それぞれ独自のオープン関数を持つ。

        ローダが見つかれば、 `require` は単一の引数 {modname} を渡してローダを呼
        ぶ。 ローダが何らかの値を返すと、 `require` はそれを
        `package.loaded[modname]` に格納する。 ローダが値を返さず、
        `package.loaded[modname]` に何の値も格納されていなければ、 `require` はこ
        のエントリに `true` を格納する。 いずれにせよ、 `require` は最終的な
        `package.loaded[modname]` の値を返す。

        モジュールのロードまたは実行でエラーがあったり、そのモジュールのローダ
        が見つからなければ、 `require` はエラーを発生する。

package.cpath                                                    *package.cpath*
        Cのローダを探すために `require` が使うパス。

        Luaは環境変数 `LUA_CPATH` (に加えて、 `luaconf.h` に定義されているもうひと
        つのデフォルトパス) を使って、 Luaのパス `package.path` と同じ方法で Cの
        パス `package.cpath` を初期化する。

package.loaded                                                  *package.loaded*
        すでにロードされたモジュールを管理するために `require` が使うテーブル。
        モジュール `modname` が要求され、 `package.loaded[modname]` が偽でなけれ
        ば、 `require` は単に、そこに格納されている値を返す。

package.loadlib({libname}, {funcname})                       *package.loadlib()*
        ホストプログラムをCのライブラリ {libname} と動的リンクする。 このライ
        ブラリの中で関数 {funcname} を探し、その関数をCの関数として返す (従っ
        て、 {funcname} は呼び出し規約 (|lua_CFunction()| を参照) に従わなければ
        ならない)。

        これは低レベルな関数であり、パッケージシステムやモジュールシステムを完
        全に迂回する。 `require` と異なり、 パス探索を行ったり拡張子を自動的に付
        加したりしない。 {libname} はCのライブラリの完全なファイル名でなければ
        ならず、 必要ならパスや拡張子も含めなければならない。 {funcname} はCの
        ライブラリがエクスポートしている完全な名前でなければならない (使ってい
        るC コンパイラやリンカに依存するであろう)。

        この関数はANSI Cのサポート範囲外である。 従って、これはいくつかのプラッ
        トフォーム (Windows, Linux, Mac OS X, Solaris, BSD, および `dlfcn` 標準
        をサポートする他のUnixシステム) でしか利用できない。

package.path                                                      *package.path*
        Luaのローダを探すために `require` が使うパス。

        起動時にLuaは環境変数 `LUA_PATH` の値、 またはその環境変数が定義されてい
        なければ `luaconf.h` で定義されているデフォルトパスで、この変数を初期化
        する。 環境変数の値に `";;"` があれば、それをデフォルトパスで置換する。

        パスはセミコロンで区切られた一連の `テンプレート` である。 各テンプレー
        トについて、 `require` は テンプレート内の疑問符 (interrogation mark) を
        `ファイル名` に置換し、 結果のファイル名をロードしようと試みる。 このファ
        イル名は、 `モジュール名` のドットを 「ディレクトリ区切り文字」 (Unixの
        `"/"` のような) で置き換えたものである。 例えば、Luaのパスが
>
               "./?.lua;./?.lc;/usr/local/?/init.lua"
<
        であった場合、モジュール `foo` のLuaのローダの検索は、 ファイル
        `./foo.lua`、 `./foo.lc`、 `/usr/local/foo/init.lua` のロードをこの順序で試み
        る。

package.preload                                              *package.preload()*
        特定のモジュールのローダを格納するテーブル (|require()| を参照)。

package.seeall({module})                                      *package.seeall()*
        `__index` フィールドがグローバル環境を参照するメタテーブルを {module} に
        セットする。 従ってこのモジュールはグローバル環境から値を継承する。 関
        数 {module} へのオプションとして使われる。

==============================================================================
5.4 文字列操作                                                *lua-lib-string*

このライブラリは、検索や部分文字列の抽出、パターンマッチングといった、文字列操
作のための一般的な機能を提供する。 Luaの文字列のインデックス付けは、最初の文字
が1の位置である (Cのように0ではない)。 文字列の末尾から逆方向にマイナス値で指
定することもできる。 つまり、最後の文字は -1 の位置で示される。

文字列ライブラリはすべて、テーブル `string` 内の関数として提供される。 また、
`__index` フィールドが自身を指す文字列用メタテーブルをセットする。 従って、文字
列関数はオブジェクト指向スタイルで使うことができる。 例えば、
`string.bytes(s, i)` は `s:byte(i)` と書くこともできる。

string.byte({s} [, {i} [, {j}]])                                 *string.byte()*
        文字 `s[i]`, `s[i+1]`, ..., `s[j]` の内部コードの数値を返す。 {i} のデフォル
        トは1、 {j} のデフォルトは {i} である。

        文字コードの数値は、プラットフォームを超えての可搬性がないことに注意。

string.char({...})                                               *string.char()*
        0個以上の整数を指定できる。 各文字が与えられた引数と等しい内部コードを
        持ち、長さが引数の数に等しい、文字列を返す。

        文字コードの数値は、プラットフォームを超えての可搬性がないことに注意。

string.dump({function})                                          *string.dump()*
        指定された関数のバイナリ表現を保持する文字列を返す。 |loadstring()| にこ
        の文字列を渡すことで、関数のコピーを作ることができる。 {function} は上
        位値を持たないLua関数でなければならない。

string.find({s}, {pattern} [, {init} [, {plain}]])               *string.find()*
        文字列 {s} 内で {pattern} の最初のマッチを探す。 もしマッチが見つかれ
        ば、 {find} は {s} 内でこのパターンがマッチした開始位置と終了位置のイ
        ンデックスを返す。 そうでなければ `nil` を返す。 三番目の省略可能な引数
        {init} は検索開始位置を指定し、デフォルト値は1で、負の値も使える。 四
        番目の省略可能な引数 {plain} に {true} が指定されると、 パターンマッチ
        ング機能はオフになり、 {pattern} 中の「魔法の」文字は無くなって、ただ
        の「部分文字列を検索する」操作になる。 {plain} を与える場合は {init}
        も与えなければならないことに注意。

        もしパターン内にキャプチャが指定されていれば、 マッチ成功時にキャプチャ
        された文字列が2つのインデックスの後に返される。

string.format({formatstring}, {...})                           *string.format()*
        最初の引数 (文字列でなければならない) で指定された記述に従い、残りの可
        変個の引数を書式化して返す。 書式文字列は標準C関数の `printf` ファミリー
        と同じルールに従う。 ただし、 `*、l、L、n、p、h` はサポートされてなくて、
        追加の `q` がある点だけが異なる。 `q` オプションは、Luaインタプリタで安全
        に読み戻せる適切な形式の文字列に書式化する。 その文字列はダブルクォー
        トの間に書かれ、 文字列中のダブルクォート、改行、埋め込まれたゼロ、バッ
        クスラッシュは正しくエスケープされる。 例えば、
>lua
               string.format('%q', 'a string with "quotes" and \n new line')
<
        は次のような文字列を生成する:
>lua
               "a string with \"quotes\" and \
                new line"
<
        `c、d、E、e、f, g、G、i、o、u, X、x` はすべて数値の引数を期待し、 `q` と
        `s` は文字列を期待する。

        この関数は埋め込まれたゼロを含む文字列を受け付けない。

string.gmatch({s}, {pattern})                                  *string.gmatch()*
        呼ばれるたびに文字列 {s} から {pattern} でキャプチャされた部分を次々と返す
        ような、イテレータ |iterator| 関数を返す。

        {pattern} にキャプチャが指定されていなければ、それぞれの呼び出しごとに、
        マッチした文字列全体を返す。

        例えば、以下のループでは
>lua
               s = "hello world from Lua"
               for w in string.gmatch(s, "%a+") do
                 print(w)
               end
<
        文字列 {s} のすべての単語について繰り返し、それぞれを別々の行に出力す
        る。次の例は、与えられた文字列から `key=value` のペアを集めてテーブルへ
        入れる:
>lua
               t = {}
               s = "from=world, to=Lua"
               for k, v in string.gmatch(s, "(%w+)=(%w+)") do
                 t[k] = v
               end
<

string.gsub({s}, {pattern}, {repl} [, {n}])                      *string.gsub()*
        パターン {pattern} をすべて {repl} によって指定された置換文字列に置き
        換えた {s} のコピーを返す。 repl は文字列、テーブル、または関数でもよい。
        `gsub` は二番目の値として、置換が行われた回数も返す。

        {repl} が文字列であれば、その値が置換に使われる。 文字 `%` はエスケープ
        文字として機能する。 {repl} 内に現れる `%n` は ({n} は1から9)、 {n} 番目
        にキャプチャされた部分文字列を表す (以下を見よ)。 シーケンス `%0` はマッ
        チ全体を表す。 シーケンス `%%` は1個の `%` を表す。

        {repl} がテーブルであれば、 そのテーブルは最初のキャプチャをキーとして
        マッチのたびに問い合わせられる。 パターンにキャプチャがなければ、マッ
        チ全体がキーとして使われる。

        {repl} が関数であれば、マッチが現れるたびにこの関数が呼ばれる。 関数に
        はキャプチャされた部分文字列が順番にすべて渡される。 パターンにキャプ
        チャが指定されていなければ、マッチした全体が唯一の引数として渡される。
        テーブル問い合わせまたは関数呼び出しから返された値が文字列か数値であれ
        ば、それが置換文字列として使われる。 そうでなくて `false` か `nil` であれ
        ば、置換は行われない (つまり、文字列中の元のマッチが維持される)。

        省略可能な最後の引数 {n} は置換が行われる最大回数を制限する。 例えば、
        {n} が1なら最初に現れる `pattern` だけが置換される。

        いくつか例を示す:
>lua
           x = string.gsub("hello world", "(%w+)", "%1 %1")
           --> x="hello hello world world"

           x = string.gsub("hello world", "%w+", "%0 %0", 1)
           --> x="hello hello world"

           x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
           --> x="world hello Lua from"

           x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
           --> x="home = /home/roberto, user = roberto"

           x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
                 return loadstring(s)()
               end)
           --> x="4+5 = 9"

           local t = {name="lua", version="5.1"}
           x = string.gsub("$name%-$version.tar.gz", "%$(%w+)", t)
           --> x="lua-5.1.tar.gz"
<

string.len({s})                                                   *string.len()*
        文字列を受け取り、その長さを返す。 空文字列 `""` の長さは0である。 文字
        列中のゼロも数えるので、 `"a\000b\000c"` の長さは5である。

string.lower({s})                                               *string.lower()*
        文字列を受け取り、その中の大文字をすべて小文字に変えた文字列のコピーを
        返す。 それ以外の文字は変化しない。 何が大文字であるかは現在のロケール
        に依存する。

string.match({s}, {pattern} [, {init}])                         *string.match()*
        文字列 {s} から {pattern} の最初の マッチ を探す。 見つかった場合、
        `match` はパターンのキャプチャを返し、 そうでなければ `nil` を返す。
        {pattern} にキャプチャがなければ、マッチ全体が返される。 3つめの省略可
        能な数値の引数 {init} は検索を開始する位置を指定する。 デフォルト値は1
        で、負の値を指定してもよい。

string.rep({s}, {n})                                              *string.rep()*
        文字列 {s} のコピーを {n} 個連結した文字列を返す。

string.reverse({s})                                           *string.reverse()*
        文字列 {s} を反転した文字列を返す。

string.sub({s}, {i} [, {j}])                                      *string.sub()*
        文字列 {s} の、位置 {i} から位置 {j} までの部分文字列を返す。 {i} にも
        {j} にも、負の値を使える。 {j} が省略されたときは `-1` とみなされる (つ
        まり文字列の長さと同じ)。 特に、 `string.sub(s,1,j)` は {s} の先頭から
        {j} 文字を取り出し、 `string.sub(s, -i)` は {s} の最後の {i} 文字を取り
        出す。

string.upper({s})                                               *string.upper()*
        文字列を受け取り、その中の小文字をすべて大文字に変えた文字列のコピーを
        返す。 それ以外の文字は変化しない。 何が小文字であるかは現在のロケール
        に依存する。

------------------------------------------------------------------------------
5.4.1  Patterns                                                  *lua-pattern*

文字クラス は文字の集合を表す。 以下の組み合わせを文字クラスの指定に使うことが
できる。

    - `x`   (`x` は 魔法の文字 `^$()%.[]*+-?` 以外の文字) --- 文字 `x` それ自身を表す。
    - `.`   (ドット) すべての文字を表す。
    - `%a`  すべてのletterを表す。
    - `%c`  すべての制御文字を表す。
    - `%d`  すべての数字を表す。
    - `%l`  すべての小文字を表す。
    - `%p`  すべての区切り記号を表す。
    - `%s`  すべての空白文字を表す。
    - `%u`  すべての大文字を表す。
    - `%w`  すべての英数文字を表す。
    - `%x`  すべての十六進数字を表す。
    - `%z`  0として表現される文字を表す。
    - `%x`  (`x` は英数文字以外) --- 文字 `x` 自身を表す。 これは魔法の文字をエスケ
          ープする標準的な方法である。 いかなる区切り文字 (魔法の文字でなくて
          も) は前に `%` を付けることでそれ自身を表すことができる。

    - `[set]`  `set` 内のすべての文字の和からなるクラスを表す。 終わりの文字と `-`
          で繋げることで、文字の範囲を表す。 上で挙げた `%x` 形式のすべてのクラ
          スも、 `set` の中で使うことができる。 それ以外の `set` 内の文字は、それ
          自身を表す。 例えば、 `[%w_]` (または `[_%w]`) は、すべての英数にアンダ
          ースコアを加えたものを表す。 `[0-7]` は八進数字を表し、 `[0-7%l%-]` は八
          進数字と小文字と `-` を表す。

          範囲とクラスの相互作用は未定義である。 つまり、 `[%a-z]` や `[a-%%]` の
          ようなパターンは意味を持たない。

    - `[^set]`  `set` の補集合を表す。 `set` の内容は上で説明したものと同じである。

ひとつの文字で表現されるクラス (`%a`、 `%c` など) はすべて、対応する大文字は補集合
を表す。 例えば `%S` は空白以外のすべての文字を表す。

文字、空白、その他の文字のグループの定義については、現在のロケールに依存する。
特に、クラス `[a-z]` は `%l` と等価ではないかもしれない。

PATTERN ITEM                                                *lua-patternitem*

パターンの要素 は以下のいずれかである。

   - 単一の文字クラス。そのクラス内の文字ひとつにマッチする。
   - 単一の文字クラスに `*` が続いたもの。 そのクラスの文字の0回以上の繰り返しに
     マッチする。 この繰り返し要素は、可能な限り長いシーケンスにマッチする。
   - 単一の文字クラスに `+` が続いたもの。 そのクラスの文字の1回以上の繰り返しに
     マッチする。 この繰り返し要素は、可能な限り長いシーケンスにマッチする。
                                                               *lua-nongreedy*
   - 単一の文字クラスに `-` が続いたもの。 そのクラスの文字の0回以上の繰り返しに
     マッチする。 `*` と異なり、この繰り返し要素は可能な限り 短い シーケンスに
     マッチする。
   - 単一の文字クラスに `?` が続いたもの。 そのクラスの文字の0回または1回の出現
     にマッチする。
   - `%n` (`n` は1から9)。 これは、 `n` 番目にキャプチャされた文字列にマッチするよう
     な要素である (下の説明を参照)。
   - `%bxy` (`x` と `y` は異なる文字)。 これは `x` で始まって `y` で終わる文字列にマッチ
     するような要素である。 `x` と `y` は 対応が取れる。 つまり、文字列を左から右
     に読んでいって、 `x` が現れるたびにカウントを `+1` し、 `y` では `-1` したとき、
     最後の `y` はカウントが0になる最初の `y` である。 例えば、要素 `%b()` はカッコ
     の対応が取れた式にマッチする。

PATTERN

pattern はパターン要素の列である。 パターンの最初に現れる `^` は対象文字列の先頭
にマッチを固定する。 パターンの最後に現れる `$` は対象文字列の最後にマッチを固定
する。 他の位置では、 `^` や `$` は特別な意味を持たず、それ自身を表す。

CAPTURES                                                        *lua-capture*

パターンはカッコで囲まれたサブパターンを持つことができ、それらは キャプチャ と
呼ばれる。 マッチが成功したとき、対象文字列の中でキャプチャにマッチした部分が
保存 (キャプチャ) され、後で使うことができる。 キャプチャはその左カッコによっ
て番号付けされる。 例えば、パターン `"(a*(.)%w(%s*))"` では、 `"a*(.)%w(%s*)"` に
マッチする部分が最初のキャプチャとして保存され (だから1番になる)、 `"."` にマッ
チする文字が2番にキャプチャされ、 `"%s*"` にマッチする部分が3番になる。

特殊なケースとして、空キャプチャ `()` は文字列の現在位置 (数値) をキャプチャする。
例えば、文字列 `"flaaap"` にパターン `"()aa()"` を適用すると、 2つのキャプチャ3と5
を得られる。

パターンには途中にゼロを含むことができない。代わりに `%z` を使う。

==============================================================================
5.5  テーブル操作                                              *lua-lib-table*

このライブラリはテーブル操作のための一般的な機能を提供する。 テーブル `table` 内
にすべての関数が提供される。 これらの関数でテーブルの「長さ」について言及する
ときは、 それは長さ演算子の結果を意味している。

table.concat({table} [, {sep} [, {i} [, {j}]]])                 *table.concat()*
        `table[i]..sep..table[i+1] ... sep..table[j]` を返す。 {sep} のデフォル
        ト値は空文字列で、 {i} のデフォルト値は1、 {j} のデフォルト値はテーブ
        ルの長さである。 {i} が {j} よりも大きい場合は空文字列を返す。

table.foreach({table}, {f})                                    *table.foreach()*
        指定された {f} を {table} のすべての要素に対して実行する。各要素に対
        し、 {f} はインデックスとその値を引数として呼び出す。もし {f} が `nil`
        以外の値を返す場合、ループは中断され、その値が返される。

        巡回中にテーブルを変更する際の注意は |next()| を参照。

table.foreachi({table}, {f})                                  *table.foreachi()*
        指定された {f} を {table} の数値のインデックスに対して実行する。各イン
        デックスに対し、 {f} はインデックスとその値を引数と呼び出す。インデッ
        クスは1からテーブルの長さ `n` まで順番に参照される。もし {f} が `nil`以外
        の値を返す場合、ループは中断され、その値が返される。

table.insert({table}, [{pos},] {value})                         *table.insert()*
        {table} の位置 {pos} に要素 {value} を挿入する。 空きスペースが必要な
        ら、他の要素を上にずらす。 {pos} のデフォルト値は `n+1` である。 `n` は
        テーブルの長さである (|lua-length| を参照)。 `table.insert(t,x)` の呼び出
        しは、テーブル `t` の最後に `x` を挿入する。

table.maxn({table})                                               *table.maxn()*
        指定したテーブルの最大の正の数値インデックスを返す。 テーブルが正の数
        値インデックスを持たなければゼロを返す。 (結果を得るために、この関数は
        テーブル全体を線形に巡回する。)

table.remove({table} [, {pos}])                                 *table.remove()*
        {table} から位置 {pos} の要素を取り除き、 必要なら他の要素を下にずらし
        て空白を埋める。 取り除かれた要素の値が返される。 {pos} のデフォルト値
        は `n` である。 `n` はテーブルの長さである(|lua-length| を参照)。
        `table.remove(t)` の呼び出しは、テーブル `t` の最後の要素を取り除く。

table.sort({table} [, {comp}])                                    *table.sort()*
        `table[1]` から `table[n]` までのテーブル要素を、指定された順序で その場で
        ソートする。 `n` はテーブルの長さである。 {comp} を与える場合、それは関
        数でなくてはならず、テーブルの要素を2つ受け取り、最初の要素が二番目よ
        りも小さいときに真を返さなければならない (ソート後、
        `not comp(a[i+1],a[i])` が真になる)。 {comp} が与えられなければ、標準の
        Luaの演算子 `<` が代わりに使われる。

ソートのアルゴリズムは安定でない。 つまり、指定された順序において等しいと考え
られる要素は、ソートによってその相対位置が変わるかもしれない。

==============================================================================
5.6  数学関数                                                   *lua-lib-math*

このライブラリは標準C数学ライブラリへのインタフェイスである。 `math` テーブルの
中にすべての関数が提供される。 このライブラリは以下の関数を提供する。

math.abs({x})                                                       *math.abs()*
        {x} の絶対値を返す。

math.acos({x})                                                     *math.acos()*
        {x} の逆余弦(ラジアン単位)を返す。

math.asin({x})                                                     *math.asin()*
        {x} の逆正弦(ラジアン単位)を返す。
        Returns the arc sine of {x} (in radians).

math.atan({x})                                                     *math.atan()*
        {x} の逆正接(ラジアン単位)を返す。

math.atan2({x}, {y})                                              *math.atan2()*
        `x/y` の逆正接(ラジアン単位)を返す、ただし両方のパラメータの符号を使用し
        結果の象限を求める。(また {y} がゼロの場合も正しく処理する。)

math.ceil({x})                                                     *math.ceil()*
        {x} 以上の最小の整数を返す。

math.cos({x})                                                       *math.cos()*
        {x} の余弦を返す(ライアン単位と仮定する)。

math.cosh({x})                                                     *math.cosh()*
        {x} の双曲線余弦を返す。

math.deg({x})                                                       *math.deg()*
        {x} の角度(ラジアン単位)を度単位で返す。

math.exp({x})                                                       *math.exp()*
        値 `e^x` を返す。

math.floor({x})                                                   *math.floor()*
        {x} 以下の最大の整数を返す。

math.fmod({x}, {y})                                                *math.fmod()*
        {x} を {y} で割った余りを返す。

math.frexp({x})                                                   *math.frexp()*
        `x = m * 2^e` となる `m` と `e` を返す。 `e` は整数、 `m` の絶対値は
        `0.5以上1未満` になる({x} がゼロの場合はゼロ)。

math.huge                                                            *math.huge*
        正の無限大の値を表す定数 `HUGE_VAL` を返す。

math.ldexp({m}, {e})                                              *math.ldexp()*
        `m * 2^e` を返す(`e` は整数でなければならない)。

math.log({x})                                                       *math.log()*
        {x} の自然対数を返す。

math.log10({x})                                                   *math.log10()*
        10 を底とする {x} の対数を返す。

math.max({x}, {...})                                                *math.max()*
        引数の中での最大値を返す。

math.min({x}, {...})                                                *math.min()*
        引数の中での最小値を返す。

math.modf({x})                                                     *math.modf()*
        {x} の整数部と小数部の2つの値を返す。

math.pi                                                                *math.pi*
        円周率(pi)を返す。

math.pow({x}, {y})                                                  *math.pow()*
        `x^y` を返す(式 `x^y` を値の計算に用いることもできる)

math.rad({x})                                                       *math.rad()*
        角度 {x}(度単位)をラジアン単位で返す。

math.random([{m} [, {n}]])                                       *math.random()*
        この関数は ANSI C で提供される簡単な疑似乱数生成関数 `rand` へのインター
        フェイスである。(統計的特性については保証されない。)

        引数なしで呼び出された場合、 `0以上1未満` の疑似乱数実数を返す。 {m} を
        指定して呼び出された場合、 `1以上m以下` の疑似乱数整数を返す。 {m} と {n}
        を指定して呼び出された場合、 `m以上n以下` の疑似乱数整数を返す。

math.randomseed({x})                                         *math.randomseed()*
        {x} をシード値とした疑似乱数を返す: 同じシード値は同じ結果になる。

math.sin({x})                                                       *math.sin()*
        {x} の正弦を返す(ライアン単位と仮定する)。

math.sinh({x})                                                     *math.sinh()*
        {x} の双曲線正弦を返す。

math.sqrt({x})                                                     *math.sqrt()*
        {x} の平方根の値を返す。(`x^0.5` でも同じ値を計算できる)

math.tan({x})                                                       *math.tan()*
        {x} の正接を返す(ライアン単位と仮定する)。

math.tanh({x})                                                     *math.tanh()*
        {x} の双曲線正接を返す。

==============================================================================
5.7  入出力機能                                                   *lua-lib-io*

I/Oライブラリは2つの異なったスタイルのファイル操作を提供する。 ひとつめは暗黙
のファイルディスクリプタを使うもので、 それらはデフォルト入力ファイルとデフォ
ルト出力ファイルに対して作用し、 すべての入出力操作はデフォルトファイルを通し
て行われる。 ふたつめのスタイルでは明示的なファイルディスクリプタを用いる。

暗黙のファイルディスクリプタを使う場合は、すべての操作はテーブル `io` で提供され
る。 明示的なファイルディスクリプタを使う場合は、 すべての操作は `io.open` が返
すファイルディスクリプタのメソッドとして提供される。

テーブル `io` は、 Cで使われる意味と同じの3つの定義済みファイルディスクリプタ
`io.stdin`、 `io.stdout`、 `io.stderr` も提供する。

例外なく、すべてのI/O関数は失敗時に `nil` (および二番目の戻り値としてエラーメッ
セージ) を返し、 成功時は `nil` 以外の何らかの値を返す。

io.close([{file}])                                                  *io.close()*
        `file:close()` と等価である。 {file} が省略されると、デフォルト出力ファ
        イルを閉じる。

io.flush()                                                          *io.flush()*
        デフォルト出力ファイルに対する `file:flush` と等価である。

io.input([{file}])                                                  *io.input()*
        ファイル名を与えて呼ぶと、その名前のファイルを (テキストモードで) 開
        き、 そのハンドルをデフォルト入力ファイルに設定する。 ファイルハンドル
        を与えて呼ぶと、単純にそのファイルハンドルがデフォルト入力ファイルに設
        定される。 引数無しで呼ぶと、現在のデフォルト入力ファイルを返す。

        エラーが起きた場合、この関数はエラーコードを返す変わりにエラーを発す
        る。

io.lines([{filename}])                                              *io.lines()*
        指定されたファイル名を読み込みモードで開き、 呼ばれるたびにファイルか
        ら1行ずつ返すイテレータ |iterator| 関数を返す。 つまり、

            `for line in io.lines(filename) do`  `body`  `end`

        はファイルのすべての行について繰り返す。 イテレータ関数は、ファイルの
        終わりを検出すると `nil` を返し (ループを終えるため)、自動的にファイルを
        閉じる。

        `io.lines()` (ファイル名を渡さない) は `io.input():lines()` と等価である。
        すなわち、デフォルト入力ファイルの各行について繰り返す。 この場合は、
        ループが終わってもファイルを閉じない。

io.open({filename} [, {mode}])                                       *io.open()*
        この関数は {mode} で指定されたモードでファイルを開く。 新しいファイル
        ハンドルを返すか、エラーの場合は `nil` とエラーメッセージを返す。

        {mode} 文字列は以下のいずれかである:

         - `"r"`   読み込みモード (デフォルト)
         - `"w"`   書き込みモード
         - `"a"`   追記モード
         - `"r+"`  更新モード (以前のデータは消えない)
         - `"w+"`  更新モード (以前のデータはすべて消える)
         - `"a+"`  追記更新モード (以前のデータは消えない) ファイルの最後のだけ
                 書き込みが許される。

        {mode} 文字列は最後に `b` も付けることができ、 システムによってはバイナ
        リモードでファイルを開くために必要である。 この文字列は標準Cの関数
        `fopen` で使われるのと同じである。

io.output([{file}])                                                *io.output()*
        `io.input` と同じであるが、デフォルト出力ファイルに対する操作である。

io.popen({prog} [, {mode}])                                         *io.popen()*
        分離されたプロセスの中でプログラム {prog} を開始し、 このプログラムか
        らのデータを読み込む (デフォルトの、{mode} が `"r"` の場合) ためか、この
        プログラムにデータを書き込む ({mode} が `"w"` の場合) ためのファイルハン
        ドルを返す。

        この関数はシステム依存であり、すべてのプラットフォームで利用可能なわけ
        ではない。

io.read({...})                                                       *io.read()*
        `io.input():read` と等価である。

io.tmpfile()                                                      *io.tmpfile()*
        テンポラリファイルのハンドルを返す。 このファイルは更新モードでオープ
        ンされ、プログラムの終了時に自動的に削除される。

io.type({obj})                                                       *io.type()*
        {obj} が有効なファイルハンドルかどうかチェックする。 {obj} がオープン
        されているファイルハンドルなら、文字列 `"file"` を返す。 {obj} がクロー
        ズされたファイルハンドルなら、文字列 `"closed file"` を返す。 {obj} が
        ファイルハンドルでなければ `nil` を返す。

io.write({...})                                                     *io.write()*
        `io.output():write` と等価である。

file:close()                                               *file:close()*
        `file` を閉じる。 ファイルハンドルがガベージコレクトされたときはそのファ
        イルは自動的に閉じられるが、 それがいつ起きるかは予測不能であることに
        注意せよ。

file:flush()                                               *file:flush()*
        `file` に書き込まれたデータを保存する。

file:lines()                                               *file:lines()*
        呼ばれるたびにファイルから新しい行を返すイテレータ (|iterator|) 関数を返
        す。 つまり、

               `for line in file:lines() do`  `body`  `end`

        はファイルのすべての行に対して繰り返す (`io.lines` と異なり、この関数は
        ループの終わりでファイルを閉じない)。

file:read({...})                                            *file:read()*
        何を読むかを指定する書式に従って、ファイル `file` から読み込む。 各書式
        について、読み込んだ文字を文字列 (または数値) として返し、 指定された
        書式でデータを読めなければ `nil` を返す。 書式を指定せずに呼ばれた場合
        は、次の行全体を読むデフォルトの書式が使われる (以下を参照)。

        利用可能なフォーマットは次の通り。

         `"*n"`    は数値を読み込む。 これは文字列の変わりに数値を読み込む唯一
                 の書式である。
         `"*a"`    は現在の位置から、残りのファイル全体を読み込む。 ファイルの
                 終わりでは、空文字列を返す。
         `"*l"`    は次の行を読み込む (行末文字は飛ばす)。 ファイルの終わりで
                 は `nil` を返す。これはデフォルトの書式である。
         `number`  はその文字数からなる文字列を読み込む。 ファイルの終わりでは
                 空文字列を返す。 数値がゼロの場合は、何も読み込まず、空文字列
                 を返す。ファイルの終わりでは `nil` を返す。

file:seek([{whence}] [, {offset}])                          *file:seek()*
        ファイルの先頭から計ったファイル位置を設定/取得する。 位置は文字列
        {whence} で指定された基準位置に {offset} を加えた値で示す。 {whence}
        は以下のいずれかである。

         - `"set"`: 基準位置は0 (ファイルの先頭)
         - `"cur"`: 基準位置は現在の位置 
         - `"end"`: 基準位置はファイルの終わり

        成功すると、関数 `seek` はファイル先頭からのバイト数で最終的なファイル位
        置を返す。 この関数が失敗すると `nil` とエラー文字列を返す。

        {whence} のデフォルト値は `"cur"` で、 {offset} は0である。 つまり、
        `file:seek()` の呼び出しは、何も変化させずに、現在の位置を返す。
        `file:seek("set")` はファイルの先頭に位置を変更する (そして0を返す)。
        `file:seek("end")` はファイルの終わりに位置を変更し、ファイルの長さを返
        す。

file:setvbuf({mode} [, {size}])                          *file:setvbuf()*
        出力ファイルのバッファリングモードを設定する。 設定可能なモードは3つあ
        る。

         `"no"`    バッファリングなし。出力操作の結果はすべて即座に現れる。
         `"full"`  完全バッファリング。出力操作はバッファが満杯の場合 (または
                 明示的にそのファイルを `flush` した場合 (|io.flush()| を参照) だ
                 け行われる。
         `"line"`  行バッファリング。出力は改行を出力するか、いくつかのスペシャ
                 ルファイル (端末デバイスとか) から入力するまでバッファされる。

        下の2つの場合では、 {size} でバッファのサイズをバイト単位で指定できる。
        デフォルトのサイズは適当である。

file:write({...})                                          *file:write()*
        引数のそれぞれの値を `file` に書き込む。 引数は文字列か数字でなければな
        らない。 それ以外の値を書き込むには、 `write` の前に `tostring`
        |tostring()| か `string.format` |string.format()| を使う。

==============================================================================
5.8  OS機能                                                       *lua-lib-os*

このライブラリはテーブル `os` を通して提供される。

os.clock()                                                          *os.clock()*
        プログラムが使ったCPU時間の概算値を秒で返す。

os.date([{format} [, {time}]])                                       *os.date()*
        与えられた文字列 {format} に従って書式化した日付と時刻を含む文字列、ま
        たはテーブルを返す。

        {time} 引数が存在すれば、それが書式化される時刻となる (この値の説明は
        `os.time` 関数 |os.time()| を参照)。 そうでなければ、 `date` は現在時刻を書
        式化する。

        {format} が `!` で始まっていたら、 日付は世界時 (Universal Time) で書式
        化される。 このオプション文字の後、 {format} が `*t` であれば、 `date` は
        以下のフィールドを持つテーブルを返す。
            - year  4桁の数値
            - month 1~23
            - day   1~31
            - hour  0~23
            - min   0~59
            - sec   0~61
            - wday  曜日、日曜日が1
            - yday  1月1日から数えた日数
            - isdst 夏時間を示すフラグ、ブーリアン

        {format} が `"*t"` でなければ、 `date` は日付を文字列として返す。 Cの関数
        `strftime` と同じルールに従って書式化される。

        引数なしで呼ばれた場合、 `date` はホストシステムと現在のロケールに依存す
        る一般的な日付と時刻の表現を返す。 (つまり、 `os.date()` は `os.date("%c")`
        と等価である)。

os.difftime({t2}, {t1})                                          *os.difftime()*
        時刻 {t1} から時刻 {t2} までの秒数を返す。 POSIX や Windows、その他の
        いくつかのシステムでは、 この値は `t2-t1` に等しい。

os.execute([{command}])                                           *os.execute()*
        この関数はCの関数 `system` と等価である。 {command} はOSのシェルによって
        実行されるコマンドを渡す。 システムに依存するステータスコードを返す。
        {command} を省略すると、シェルが利用可能ならゼロ以外を返し、そうでなけ
        ればゼロを返す。

os.exit([{code}])                                                    *os.exit()*
        省略可能な {code} でCの関数 `exit` を呼んでホストプログラムを終了させる。
        {code} のデフォルト値は成功を表すコードである。

os.getenv({varname})                                               *os.getenv()*
        プロセスの環境変数 {varname} の値を返す。 変数が未定義なら `nil` を返す。

os.remove({filename})                                              *os.remove()*
        指定された名前のファイルまたはディレクトリを消す。 消すディレクトリは
        空でなければならない。 この関数が失敗した場合は `nil` とエラーメッセージ
        を返す。

os.rename({oldname}, {newname})                                    *os.rename()*
        {oldname} という名前のファイルまたはディレクトリを {newname} にリネー
        ムする。 この関数が失敗した場合は `nil` とエラーメッセージを返す。

os.setlocale({locale} [, {category}])                           *os.setlocale()*
        プログラムの現在のロケールを設定する。 {locale} はロケールを表す文字列
        である。 {category} は変更したいカテゴリを表す省略可能な文字列で、以下
        のいずれかである。 `"all"`, `"collate"`, `"ctype"`, `"monetary"`, `"numeric"`,
        or `"time"`。 デフォルトのカテゴリは `"all"` である。 この関数は新しいロ
        ケールの名前を返す。 あるいは要求が受け付けられなければ `nil` を返す。

os.time([{table}])                                                   *os.time()*
        引数無しで呼ばれたときは現在の時刻を返し、 引数がある場合は、与えられ
        たテーブルで指定された日付と時刻を表す時刻を返す。 このテーブルはフィー
        ルド `year`, `month`, と `day` を持たなければならず、 省略可能だがフィール
        ド `hour`, `min`, `sec`, と `isdst` があっても良い (これらのフィールドの説明
        は `os.date` 関数 |os.date()| を参照)。

        戻り値は数値であり、その意味はシステムに依存する。 POSIX や Windows、
        およびいくつかのシステムでは、 特定の開始時刻 (「エポック」)からの経過
        時間を秒で表している。 それ以外のシステムでは、その意味は不明であり、
        `time` の戻り値は `date` と `difftime` の引数としてのみ使うことができる。

os.tmpname()                                                      *os.tmpname()*
        テンポラリファイルとして使えるファイル名を返す。 このファイルは使う前
        に明示的にオープンする必要があり、 要らなくなったら明示的に削さなけれ
        ばならない。

==============================================================================
5.9  デバッグライブラリ                                        *lua-lib-debug*

このライブラリはLuaプログラムへのデバッグインタフェイスの機能を提供する。 この
ライブラリを使うときは注意すべきである。 ここで提供される関数はデバッグやそれ
に似たプロファイリングのようなタスクにのみ使うべきである。 普通のプログラミン
グツールとしてこれらを使う誘惑に抵抗するように。 これらは非常に遅い。 さらに言
えば、いくつかの関数はLuaコードについてのいくつかの仮定 (関数のローカル変数は
他の関数からアクセスできないとか、ユーザーデータのメタテーブルはLuaから変更で
きないとか) を侵害し、安全なコードを危うくする恐れがある。

このライブラリのすべての関数は `debug` テーブル内に提供される。

debug.debug()                                                    *debug.debug()*
        ユーザーとの対話モードに入り、ユーザーが入力した文字列を実行する。 単
        純なコマンドや他のデバッグ機能を使って、 ユーザーはグローバル変数やロー
        カル変数を調べたり値を変更したり式を評価したりその他ができる。 ユーザー
        が `cont` だけの行を入力すると対話モードを終えて実行を継続する。

        `debug.debug` で実行されるコマンドは、 どの関数のレキシカルスコープにも
        入っていないので、 ローカル変数へは直接アクセスできないことに注意。

debug.getfenv(o)                                               *debug.getfenv()*
        オブジェクト {o} の環境を返す。

debug.gethook([{thread}])                                      *debug.gethook()*
        現在のフック関数、フックマスク、フックカウント (`debug.sethook` 関数で設
        定されたもの) を返す。

debug.getinfo([{thread},] {function} [, {what}])               *debug.getinfo()*
        関数に関する情報をテーブルに入れて返す。 関数を直接指定するか数値を指
        定することができる。 数値は、関数が走っているコールスタックのレベルを
        意味し、 レベル0は現在の関数 (`getinfo` 自身)、 レベル1は `getinfo` を呼び
        出した関数で、以下同様。 {function} がアクティブな関数の数よりも大きい
        数値であれば `getinfo` は `nil` を返す。

        {what} はどのフィールドを埋めるかを記述する文字列で、 戻り値のテーブル
        には `lua_getinfo` (|lua_getinfo()| を参照)から返されるフィールドがすべて
        含まれている。 {what} のデフォルト値では有効なすべての情報を取得する。
        もし存在すれば、 `f` オプションは `func` という名前のフィールドにその関数
        自身を入れる。オプション `L` が指定されている場合、有効な行のテーブルを
        含む `activelines` という名前のフィールドが追加される。

        例えば、式 `debug.getinfo(1,"n").name` は現在の関数の名前を返す (もし適
        当な名前があれば)。 `debug.getinfo(print)` は `print` 関数に関するすべての
        利用可能な情報を持つテーブルを返す。

debug.getlocal([{thread},] {level}, {local})                  *debug.getlocal()*
        スタックレベル level の関数の、インデックス {local} のローカル変数の、
        名前と値を返す。 最初の引数かローカル変数がインデックス1で、以下同様に
        最後の有効なローカル変数まで続く。 もし指定されたインデックスのローカ
        ル変数がなければ `nil` を返し、 {level} が範囲外であればエラーを発する
        (`debug.getinfo` (|debug.getinfo()| を参照) を使ってレベルが有効かどうか
        チェックできる)。

        `(` (開き括弧) で始まる変数名は内部的な変数 (ループ制御変数、一時変数、
        Cの関数のローカルなど) を表している。

debug.getmetatable({object})                              *debug.getmetatable()*
        指定した {object} のメタテーブルを返す。 メタテーブルを持っていなけれ
        ば `nil` を返す。

debug.getregistry()                                        *debug.getregistry()*
        レジストリテーブル (|lua-registry| を参照) を返す。

debug.getupvalue({func}, {up})                              *debug.getupvalue()*
        関数 {func} の、インデックス {up} の上位値の、名前と値を返す。 指定さ
        れたインデックスの上位値が存在しなければ `nil` を返す。

debug.setfenv({object}, {table})                               *debug.setfenv()*
        指定した {object} の環境を指定した {table} にする。 {object} を返す。

debug.sethook([{thread},] {hook}, {mask} [, {count}])          *debug.sethook()*
        指定された関数をフックに設定する。 文字列 {mask} と数値 {count} は、い
        つフックが呼ばれるかを記述する。 文字列 {mask} は以下の文字からなる:

         - `"c"` : フックはLuaが関数を呼ぶたびに呼ばれる。
         - `"r"` : フックはLuaが関数から戻るたびに呼ばれる。
         - `"l"` : フックはLuaがコードの新しい行に入るたびに呼ばれる。

        {count} がゼロでなければ、フックは {count} 命令が実行されるたびに、そ
        の直後に呼ばれる。

        引数なしで呼ぶとフックは無効になる。

        フックが呼ばれたとき、最初の引数はフックを起動したイベントを示す以下の
        いずれかの文字列である。 `"call"`, `"return"`, `"tail return"`, `"line"`,
        `"count"`。 lineイベントの場合、フックは二番目の引数に新しい行番号が得ら
        れる。 `"tail return"` を除いて、 フックの内部でレベル2の `getinfo` を呼べ
        ば、実行中の関数に関する情報をもっと得られる (レベル0は `getinfo` 関数自
        身で、レベル1はフック関数である)。 `"tail return"` はLuaが復帰をシミュ
        レートしているだけであり、 `getinfo` は正しくないデータを返すだろう。

debug.setlocal([{thread},] {level}, {local}, {value})         *debug.setlocal()*
        スタックレベル {level} の関数の、インデックス {local} のローカル変数
        に、値 {value} を格納する。 指定されたインデックスのローカル変数が存在
        しなければ `nil` を返し、 {level} が範囲外であればエラーを発する
        (`getinfo` を使ってレベルが有効かどうかチェックできる)。 そうでなければ、
        ローカル変数の名前を返す。

debug.setmetatable({object}, {table})                     *debug.setmetatable()*
        指定した {object} のメタテーブルを指定した {table} (`nil` でも良い) にす
        る。

debug.setupvalue({func}, {up}, {value})                     *debug.setupvalue()*
        関数 {func} の、インデックス {up} の上位値に、値 {value} を格納する。
        指定されたインデックスの上位値が存在しなければ `nil` を返す。 そうでなけ
        れば、上位値の名前を返す。

debug.traceback([{thread},] [{message} [,{level}]])          *debug.traceback()*
        コールスタックのトレースバックを出力した文字列を返す。 省略可能な
        {message} 文字列は、トレースバックの最初に付け加えられる。 省略可能な
        {level} 数値は開始するトレースバックのレベルを指定する(既定では1)。

==============================================================================
A  参考文献                                               *lua-ref-bibliography*

本ヘルプファイルは、次の主なリファレンスからわずかに改変したものである:

 - R. Ierusalimschy, L. H. de Figueiredo, and W. Celes.,
   "Lua: 5.1 reference manual", https://www.lua.org/manual/5.1/manual.html

Lua については、以下の参考文献で解説されている:

 - R. Ierusalimschy, L. H. de Figueiredo, and W. Celes.,
   "Lua --- an extensible extension language".
   "Software: Practice & Experience" 26, 6 (1996) 635-652.

 - L. H. de Figueiredo, R. Ierusalimschy, and W. Celes.,
   "The design and implementation of a language for extending applications".
   "Proc. of XXI Brazilian Seminar on Software and Hardware" (1994) 273-283.

 - L. H. de Figueiredo, R. Ierusalimschy, and W. Celes.,
   "Lua: an extensible embedded language".
   "Dr. Dobb's Journal" 21, 12 (Dec 1996) 26-33.

 - R. Ierusalimschy, L. H. de Figueiredo, and W. Celes.,
   "The evolution of an extension language: a history of Lua".
   "Proc. of V Brazilian Symposium on Programming Languages" (2001) B-14-B-28.

==============================================================================
B  著作権とライセンス                                   *lua-ref-copyright*

本ヘルプファイルは、Lua 5.1 及び Lua 5.1 マニュアルと同じ著作権とライセンスを
有する:

Copyright (c) 1994-2006 Lua.org, PUC-Rio.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

==============================================================================
C  LUAREF DOC                                   *lua-ref-doc*

これは Lua 5.1 のリファレンスを含むヘルプファイルである。いくつかの例外と改変
はあるが、殆どは Lua 5.1 リファレンスマニュアルのコピーである
(|lua-ref-bibliography| を参照)。使用法については |lua-ref-doc| を参照。著作権情報
については、 |lua-ref-copyright| を参照。

このリファレンスを実装するための主要なアイデアとコンセプトは、
Christian Habermann の CRefVim から拝借している
(https://www.vim.org/scripts/script.php?script_id=614)。


Nvim 内包のドキュメントに最適化されている。元のプラグインはこちら:
https://www.vim.org/scripts/script.php?script_id=1291

==============================================================================
D  日本語訳について

本ヘルプファイルは、komiyamma氏の Lua 5.1 リファレンスマニュアル日本語訳を元
に、Nvim のヘルプファイル用に改変したものである。原本はこちら:
https://github.com/komiyamma/lua_reference_manual_ja/blob/main/docs/lua5.1.html

 vim:tw=78:ts=4:ft=help:norl:et
