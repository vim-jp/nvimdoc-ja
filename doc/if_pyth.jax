*if_pyth.txt*   Nvim 0.12        Last change: 2025-08-24


                         NVIMリファレンスマニュアル


NvimのPythonインターフェイス				*if_pyth* *python* *Python*

|provider-python| で更なる情報を確認してください。

                                            目次を確認するには |gO| をタイプ。

==============================================================================
コマンド						*python-commands*

					*:python* *:py* *E263* *E264* *E887*
:[range]py[thon] {stmt}
			Pythonのステートメント{stmt}を実行します。`:python` コ
			マンドが機能するか簡単にチェックするには: >vim
				:python print("Hello")

:[range]py[thon] << [trim] [{endmarker}]
{script}
{endmarker}
			Pythonのスクリプト{script}を実行します。Vim スクリプト
			に Python のコードを含めるのに便利です。Python が必須
			です、 |script-here| を参照してください。

"<<" の後に [endmarker] を省略した時は |:append| や |:insert| のようにドット
'.' が使われます。詳細については |:let-heredoc| を参照。

この形の |:python| コマンドはVim scriptにPythonコードを埋め込むのに特に便利で
す。

例: >vim
	function! IcecreamInitialize()
	python << EOF
	class StrawberryIcecream:
		def __call__(self):
			print('EAT ME')
	EOF
	endfunction

使っている Python のバージョンを見るには: >vim
	:python print(sys.version)

"sys" をインポートする必要はありません。これはデフォルトで行われます。

							*python-environment*
Vim で設定した環境変数は Python で常に利用できるとは限りません。Vim と Python
がどのようにビルドされたかに依存します。以下も参照
https://docs.python.org/3/library/os.html#os.environ

Note: Pythonはインデントに関して非常に繊細です。"class" の行と "EOF" の行はまっ
たくインデントしないでください。

							*:pydo*
:[range]pydo {body}	Python の式を "def _vim_pydo(line linenr): {body}" と
			いう形で実行します。引数には各行のテキスト (末尾の
			<EOL> なし) と行番号が渡されます。関数は文字列か None
			を返さなければなりません。文字列を返すと行がその文字列
			で置換されます。[range] を指定しなかった場合は "1,$"
			(ファイル全体) が範囲となります。

例:
>vim
	:pydo return "%s\t%d" % (line[::-1], len(line))
	:pydo if line: return "%4d: %s" % (linenr, line)
<
Pythonを使って範囲をフィルタリングするには、`:py` と組み合わせた `:pydo` を使
用することができます。例えば: >vim

	:py3 << EOF
	needle = vim.eval('@a')
	replacement = vim.eval('@b')

	def py_vim_string_replace(str):
		return str.replace(needle, replacement)
	EOF
	:'<,'>py3do return py_vim_string_replace(line)
<
							*:pyfile* *:pyf*
:[range]pyf[ile] {file}
			{file}内のPythonスクリプトを実行します。引数はそのまま
			一つのファイル名として使われます。

これら２つのコマンドは、本質的には同じことを行います - つまり、Pythonのコード
を、与えられた "現在の範囲" |python-range| に対して実行します。

:pythonの場合には、実行されるコードはコマンドラインで与えられたものです。
:pyfileの場合には、実行されるコードは与えられたファイルの中身です。

Pythonのコマンドは |sandbox| の中では使えません。

引数を渡すためには明示的に sys.argv[] を使って設定してください。例: >vim

	:python sys.argv = ["foo", "bar"]
	:pyfile myscript.py

いくつか例を挙げます					*python-examples* >vim
>vim
	:python from vim import *
	:python current.line = str.upper(current.line)
	:python print("Hello")
	:python str = current.buffer[42]

変更 - importsなど - は、Python REPL と同様に、次のコマンドに引き継がれます。

							*script-here*
インラインでスクリプト言語を使用する場合、その言語がサポートされていないときは
これをスキップすることをお勧めします。
>vim
   if has('python')
     python << EOF
       print("python works")
   EOF
   endif
<
"EOF" は行の先頭に空白なしで置く必要があることに注意してください。

==============================================================================
vimモジュール					*python-vim*

Pythonコードは、vimモジュールを通して、vimに自由にアクセスすることができます
(ただひとつの例外を除いて - 以下の |python-output| を参照)。vimモジュールは２つ
のメソッド、３つの定数、そして１つのエラーオブジェクトを実装しています。これを
使うにはvimモジュールをimportする必要があります。 >vim
	:python import vim

概要 >vim
	:py print("Hello")		# メッセージを表示
	:py vim.command(cmd)		# exコマンドを実行
	:py w = vim.windows[n]		# ウィンドウ "n" を得る
	:py cw = vim.current.window	# 現在のウィンドウを得る
	:py b = vim.buffers[n]		# バッファ "n" を得る
	:py cb = vim.current.buffer	# 現在のバッファを得る
	:py w.height = lines		# ウィンドウの高さを設定する
	:py w.cursor = (row, col)	# ウィンドウのカーソル位置を設定する
	:py pos = w.cursor		# (row, col)の組を得る
	:py name = b.name		# バッファのファイル名を得る
	:py line = b[n]			# バッファから１行を得る
	:py lines = b[n:m]		# バッファから一連の行を得る
	:py num = len(b)		# 行数を得る
	:py b[n] = str			# バッファ内の１行を設定する
	:py b[n:m] = [str1, str2, str3]	# １度に数行を設定する
	:py del b[n]			# １行を削除する
	:py del b[n:m]			# 数行を削除する


"vim" モジュールのメソッド

vim.command(str)					*python-command*
	vim(exモード)のコマンドstrを実行します。戻り値はありません。
	例: >vim
	    :py vim.command("set tw=72")
	    :py vim.command("%s/aaa/bbb/g")
<	ノーマルモードのコマンドを実行するには、次の定義が使われます: >python
		def normal(str):
			vim.command("normal "+str)
		# '...' は、２重引用符を含む文字列の境界に使われることに注意。
		normal('"a2dd"aP')

vim.eval(str)						*python-eval*
	vim 内の式評価を使って、式を評価します (|expression|を参照)。戻り値は、
	次の通り:
	- Vim の式を評価した結果が文字列か数値ならば文字列
	- Vim の式を評価した結果がリストならばリスト
	- Vim の式を評価した結果が Vim の辞書ならば辞書
	辞書およびリストは再帰的に展開されます。
	例: >vim
	    :py text_width = vim.eval("&tw")
	    :py str = vim.eval("12+12")		
	    " 結果は文字列であることに注意!数値に変換するには int() を使うこと

vim.strwidth(str)					*python-strwidth*
	|strwidth()| と同じ。str の画面上の幅を数値で返す。タブ文字は 1 幅とし
	てカウントされます。

vim.foreach_rtp(callable)				*python-foreach_rtp*
	'runtimepath' の各パスについてコーラブル (callable) を呼び出します。
	コーラブルが None 以外の値を返すか、例外が発生するか、パスの最後まで処
	理が進むと停止します。コーラブルが None 以外の値を返して停止した場合
	は、vim.foreach_rtp 関数はその値を返します。

`vim.chdir(*args, **kwargs)`				*python-chdir*
`vim.fchdir(*args, **kwargs)`				*python-fchdir*
	os.chdir、os.fchdir を実行し、Vim にそのことを通知します。Note: これら
	の関数は直接は使用しません。代わりに os.chdir と os.fchdirを使います。
	os.fchdir が存在しない場合の vim.fchdir の動作は未定義です。

"vim" モジュールのエラーオブジェクト

vim.error						*python-error*
	vimのエラーに遭遇したとき、Pythonは型vim.errorの例外を発生させます。
	例: >python
		try:
			vim.command("put a")
		except vim.error:
			# レジスタaが空

モジュール "vim" の定数
	モジュール "vim" の定数は、実際には定数ではありません。よって代入し直
	すことができます。しかし、それは馬鹿げたことです。その変数が参照してい
	るvimオブジェクトへのアクセスができなくなってしまうからです。

vim.buffers						*python-buffers*
	一連のvimバッファへのアクセスを提供するマッピングオブジェクト。
	次の操作がサポートされています: >vim
	    :py b = vim.buffers[i]	# インデックス化する (読取り専用)
	    :py b in vim.buffers	# メンバかどうか調べる
	    :py n = len(vim.buffers)	# 要素の個数
	    :py for b in vim.buffers:	# バッファリストのイテレート

vim.windows						*python-windows*
	一連のvimウィンドウへのアクセスを提供するシーケンスオブジェクト。
	このオブジェクトは次の操作をサポートしています: >vim
	    :py w = vim.windows[i]	# インデックス化する (読取り専用)
	    :py w in vim.windows	# メンバかどうか調べる
	    :py n = len(vim.windows)	# 要素の個数
	    :py for w in vim.windows:	# シーケンシャルアクセス
<	Note: vim.windows オブジェクトは常に現在のタブページ内にアクセスしま
	す。 |python-tabpage| .windows オブジェクトは親である |python-tabpage|
	オブジェクトに結びつけられて、常にそのタブページのウィンドウを参照しま
	す (タブページが削除されていたときは vim.error 例外が発生します)。vim
	モジュールや |python-tabpage| オブジェクトへの参照を維持しなくても、参
	照は保持されます。プロパティも失われません。

vim.tabpages						*python-tabpages*
	Vim のタブページの一覧へのアクセスを提供するシーケンスオブジェクト。
	このオブジェクトは次の操作をサポートしています: >vim
	    :py t = vim.tabpages[i]	# インデックス化する (読取り専用)
	    :py t in vim.tabpages	# メンバかどうか調べる
	    :py n = len(vim.tabpages)	# 要素の個数
	    :py for t in vim.tabpages:	# シーケンシャルアクセス

vim.current						*python-current*
	vim内で使える様々な "現在の" オブジェクトへの、(特定の属性を通した)
	アクセスを提供するオブジェクト: >vim
		vim.current.line	現在の行 (RW)			String
		vim.current.buffer	現在のバッファ (RW)		Buffer
		vim.current.window	現在のウィンドウ (RW)		Window
		vim.current.tabpage	現在のタブページ (RW)		TabPage
		vim.current.range	現在の行の範囲 (RO)		Range
<
	最後のものに関しては、若干の説明が必要でしょう。:python、:pyfileコマン
	ドで、範囲が指定された場合、この行の範囲は、"現在の範囲" として扱われ
	ます。範囲はバッファに少し似ていますが、全てのアクセスは行のサブセット
	に制限されます。詳細は|python-range|を参照してください。

	Note: vim.current.{buffer,window,tabpage} に値を代入するときはその値が
	有効なオブジェクト(|python-buffer|、 |python-window| 、 |python-tabpage| )
	であることが期待されます。値を代入するとバッファ、ウィンドウ、またはタ
	ブページの切り替えが起こります (|autocommand| も実行される)。これが唯
	一 python で UI オブジェクトを切り替える方法です。
	|python-tabpage|.window 属性に代入することはできません。自動コマンドを
	発行させずに切り替えるには次のようにします: >vim
	    py << EOF
	    saved_eventignore = vim.options['eventignore']
	    vim.options['eventignore'] = 'all'
	    try:
	        vim.current.buffer = vim.buffers[2] # バッファ 2 へ切り替え
	    finally:
	        vim.options['eventignore'] = saved_eventignore
	    EOF
<
vim.vars						*python-vars*
vim.vvars						*python-vvars*
	辞書に似たオブジェクトで、グローバル変数 (|g:|) と Vim 変数 (|v:|) へ
	の参照です。

vim.options						*python-options*
	グローバルオプションへの読み書きアクセスを提供するマップオブジェクト
	(値の取得と設定のみ対応)。
	Note: |:set| と違い、グローバルオプションへのアクセスのみ提供します。
	このオブジェクトを使ってローカルオプションの値を読み書きすることはでき
	ません。指定した名前のグローバルオプションが存在しない場合は KeyError
	例外が発生します (例えば |global-local| オプションやグローバルオプショ
	ンへのアクセスでは KeyError は発生しませんが、ウィンドウオプションや
	バッファオプションへのアクセスでは例外が発生します)。バッファオプショ
	ンへのアクセスには |python-buffer| オブジェクトを使います。ウィンドウ
	オプションへのアクセスには |python-window| オブジェクトを使います。

	このオブジェクトの型は vim モジュールの "Options" 属性で取得できます。

Pythonからの出力					*python-output*
	Pythonコードからの全ての出力は、Vimのメッセージエリアに表示されます。
	標準出力はインフォメーションメッセージとして、エラー出力はエラーメッ
	セージとして表示されます。

	実装のレベルでいうと、sys.stdout(printステートメントによる出力も含む)
	に向けられる全ての出力が、インフォメーションメッセージとしてvimに表示
	され、sys.stderr(エラートレースバックを含む)に向けられる全ての出力が、
	エラーメッセージとしてvimに表示されています。

							*python-input*
	入力(sys.stdinを通した入力、input()、raw_input()を含む)はサポートされ
	ず、プログラムをクラッシュさせる可能性があります。これはたぶん修正され
	るべき問題です。

				  *python3-directory* *pythonx-directory*
Python における 'runtimepath' の処理			*python-special-path*

Python では、'runtimepath' のパスのリストを使う代わりに、vim.VIM_SPECIAL_PATH
という特別なディレクトリが使われます。このディレクトリが sys.path 内で使われる
とき、そして vim.path_hooks が sys.path_hooks 内で使われるとき、'runtimepath'
の各パス {rtp} に対して {rtp}/python3 と {rtp}/pythonx のモジュールがロードさ
れます。

実装は以下のようになっています。ただし実際は C で書かれています: >python

    from imp import find_module, load_module
    import vim
    import sys

    class VimModuleLoader(object):
        def __init__(self, module):
            self.module = module

        def load_module(self, fullname, path=None):
            return self.module

    def _find_module(fullname, oldtail, path):
        idx = oldtail.find('.')
        if idx > 0:
            name = oldtail[:idx]
            tail = oldtail[idx+1:]
            fmr = find_module(name, path)
            module = load_module(fullname[:-len(oldtail)] + name, *fmr)
            return _find_module(fullname, tail, module.__path__)
        else:
            fmr = find_module(fullname, path)
            return load_module(fullname, *fmr)

    # It uses vim module itself in place of VimPathFinder class: it does not
    # matter for python which object has find_module function attached to as
    # an attribute.
    class VimPathFinder(object):
        @classmethod
        def find_module(cls, fullname, path=None):
            try:
                return VimModuleLoader(_find_module(fullname, fullname, path or vim._get_paths()))
            except ImportError:
                return None

        @classmethod
        def load_module(cls, fullname, path=None):
            return _find_module(fullname, fullname, path or vim._get_paths())

    def hook(path):
        if path == vim.VIM_SPECIAL_PATH:
            return VimPathFinder
        else:
            raise ImportError

    sys.path_hooks.append(hook)

vim.VIM_SPECIAL_PATH					*python-VIM_SPECIAL_PATH*
	Vim のパスフックに関連付けられた文字列定数。Vim によって設定されたパス
	フックが vim.VIM_SPECIAL_PATH 定数以外のパスに対して呼び出された場合は
	ImportError が発生します。そうでなければ特殊ローダが使用されます。

	Note: この定数の値を直接使用しないこと。常に vim.VIM_SPECIAL_PATH オブ
	      ジェクトを使用してください。

vim.find_module(...)					*python-find_module*
vim.path_hook(path)					*python-path_hook*
	上述のパスフックの実装に使われるメソッドとオブジェクト。sys.meta_path
	で vim.path_hook を使って何かをするようなことがなければ、これらを直接
	使用することはないでしょう。これらのオブジェクトが Vim の将来のバージョ
	ンでも存在するかどうかは保証されません。

vim._get_paths						*python-_get_paths*
	パスフックで検索されるパスのリストを返すメソッド。将来のバージョンのこ
	とを考えるならこのメソッドに依存すべきではありません。デバッグなどに使
	います。

	'runtimepath' の各パスに対して {rtp}/python3 と {rtp}/pythonx ディレク
	トリのリストを返します。


==============================================================================
バッファオブジェクト					*python-buffer*

バッファオブジェクトは、vimのバッファを表します。バッファオブジェクトを取得す
るはいくつかの方法があります:
	- vim.current.bufferを介して (|python-current|)
	- vim.buffersのインデックス化から (|python-buffers|)
	- ウィンドウの "buffer" 属性から (|python-window|)

バッファオブジェクトは二つの読み取り専用属性を持っています。name はバッファの
フルファイル名です。number はバッファ番号です。バッファオブジェクトは 3 つのメ
ソッドを持っています (append、mark、range。以下参照)。

バッファオブジェクトは、シーケンスオブジェクトとして扱うこともできます。この文
脈では、バッファオブジェクトは文字列のリスト (そう、これはmutableです) のよう
に振舞います。各要素はバッファの行です。有用なシーケンス操作の全て、つまり、イ
ンデックス操作、インデックスによる代入、スライシング、スライスへの代入が期待通
りに機能します。バッファのインデックス操作 (スライシング) の結果は、文字列 (文
字列のリスト) であることを注意しておきます。これはひとつの例外的な結果をもたら
します - b[:] は b とは異なるのです。特に、"b[:] = None" はバッファの全てを削
除するが、"b = None" は変数 b を更新するだけで、バッファには何の影響も与えませ
ん。

バッファのインデックスは、Pythonでは普通はゼロから始まります。これは、1から始
まるvimの行番号と異なります。これは、特にvimの行番号を使うmarks(以下を参照)を
扱う際に問題となります。

バッファオブジェクトの属性は次の通りです:
	b.vars		バッファ変数 (|buffer-variable|) にアクセスするための
			辞書オブジェクト。
	b.options	バッファオプションにアクセスするためのマップオブジェク
			ト (値の取得、設定、削除をサポート)。ウィンドウオプ
			ションへのアクセスは |python-window|.options を使って
			ください。ウィンドウオプションに対しては KeyError 例外
			が発生します。グローバルの値とローカルの値を両方持つオ
			プション (|global-local|) で、ローカルの値がない場合は
			None が返ります。
	b.name		文字列。読み書き可。バッファ名 (フルパス)。
			Note: b.name に値を設定すると自動コマンドの
			|BufFilePre| と |BufFilePost| イベントが発生します。
	b.number	バッファ番号。 |python-buffers| のキーとして使えます。
			読み込み専用。
	b.valid		True または False。関連バッファが破棄されるとバッファ
			オブジェクトは無効となる。

バッファオブジェクトのメソッドは次の通りです:
	b.append(str)	バッファに行を追加
	b.append(str, nr)  バッファの "nr" 行目の下に行を追加。
	b.append(list)	バッファに一連の行を追加
			appendメソッドに文字列のリストを与えるオプションは、
			Python組込みのリストオブジェクトの等価なメソッド
			とは違うことに注意してください
	b.append(list, nr)  バッファの "nr" 行目の下に一連の行を追加
	b.mark(name)	名前付きマークの位置を示す(row,col)の組を返す
			(これは[]"<> marksでも得られる)
	b.range(s,e)	与えられたバッファのs行目からe行目(s行とe行も含む
			|inclusive|)を示すレンジオブジェクト(|python-range|を
			参照)を返す

Note 行を追加するときは、その行に改行文字 '\n' が含まれてはなりません。末尾
の '\n' は許されますが、無視されます。そのため次のようなことができます: >vim
	:py b.append(f.readlines())

バッファオブジェクトの型は vim モジュールの "Buffer" 属性で取得できます。

例 (bは現在のバッファに割り当てられているとします) >vim
	:py print(b.name)		# バッファのファイル名を出力
	:py b[0] = "hello!!!"		# 先頭の行を置換
	:py b[:] = None			# 全てのバッファを削除
	:py del b[:]			# 全てのバッファを削除
	:py b[0:0] = "add a line"	# 先頭に行を追加
	:py del b[2]			# 行を削除 (３番目)
	:py b.append("bottom")		# 最後に行を追加
	:py n = len(b)			# 行数
	:py (row,col) = b.mark('a')	# 名前付きマーク
	:py r = b.range(1,5)		# バッファの部分範囲
	:py b.vars["foo"] = "bar"	# b:foo への代入
	:py b.options["ff"] = "dos"	# ファイルフォーマット設定
	:py del b.options["ar"]		# :set autoread< と同じ

==============================================================================
レンジオブジェクト					*python-range*

レンジオブジェクトは、vimバッファの一部分を表します。レンジオブジェクトを取得
するにはいくつかの方法があります:
	- vim.current.rangeを介して (|python-current|)
	- バッファのrange()メソッドから (|python-buffer|)

レンジオブジェクトの操作は、バッファオブジェクトのそれとほとんど同じです。
しかし、全ての操作は範囲内の行に制限されます(もちろん、行の範囲は部分の割当て、
行の削除、あるいはrange.append()メソッドによって変更できます)。

レンジオブジェクトの属性:
	r.start		選択範囲でのバッファ内の最初の行。
	r.end		選択範囲でのバッファ内の最後の行。

レンジオブジェクトのメソッド:
	r.append(str)	その範囲に行を追加する
	r.append(str, nr)  "nr" 行目の後に追加する
	r.append(list)	その範囲にリストで与えられた複数行を追加する。
			Note これはPythonのリストオブジェクトに対する操作とは
			異なることに注意してください。
	r.append(list, nr)  "nr" 行目の後に追加する

Range オブジェクトの型は vim モジュールの "Range" 属性で取得できます。

例 (r が現在の範囲であると仮定する): >python
	# 範囲内のすべての行をデフォルトのプリンターに送信する
	vim.command("%d,%dhardcopy!" % (r.start+1,r.end+1))

==============================================================================
ウィンドウオブジェクト				*python-window*

ウィンドウオブジェクトは、vimのウィンドウを表現します。ウィンドウオブジェクト
を取得するには、いくつかの方法があります:
	- vim.current.windowを介して (|python-current|)
	- vim.windowsのインデックス化から (|python-windows|)
	- タブページの "windows" 属性のインデックス化から (|python-tabpage|)
	- タブページの "window" 属性から (|python-tabpage|)

ウィンドウオブジェクトは、それらの属性を通してのみ操作できます。これらはメソッ
ドを持たず、シーケンスも他のインターフェイスもありません。

ウィンドウの属性:
	buffer (読取り専用)	そのウィンドウに表示されているバッファ
	cursor (読み書き)	そのウィンドウの現在のカーソルの位置
				これは(row,col)の組で表される
	height (読み書き)	ウィンドウの高さ、行の数で
	width (読み書き)	ウィンドウの幅、列の数で
	vars (読み専用)		ウィンドウの |w:| 変数。この属性自体には代入で
				きないが、この属性を使ってウィンドウ変数を変更
				できる。
	options (読み専用)	ウィンドウオプション。この属性自体には代入でき
				ないが、この属性を使ってウィンドウオプションを
				変更できる。ウィンドウオプションのみアクセス可
				能。バッファオプションは |python-buffer| で、
				グローバルオプションは |python-options| でアク
				セスする。オプションがグローバルの値とローカル
				の値を両方持つオプション (|global-local|) で、
				ローカルの値がない場合は None が返ります。
	number (読み専用)	ウィンドウ番号。一つ目のウィンドウの番号は 1
				です。番号が不明な場合は 0 が返ります (例え
				ば、他のタブページに関連付けられたウィンドウオ
				ブジェクトである場合)。
	row, col (読み専用)	スクリーン上でのウィンドウの表示位置。値は 0
				から始まります。
	tabpage (読み専用)	ウィンドウのタブページ。
	valid (read-write)	True または False。関連ウィンドウが閉じられる
				とウィンドウオブジェクトは無効になる。

heightはスクリーンが水平方向に分割されているときのみ書き込み可能です。
widthはスクリーンが垂直方向に分割されているときのみ書き込み可能です。

Window オブジェクトの型は vim モジュールの "Window" 属性で取得できます。

==============================================================================
タブページオブジェクト					*python-tabpage*

タブページオブジェクトは、vim のタブページを表現します。タブページオブジェクト
を取得するにはいくつかの方法があります:
	- vim.current.tabpageを介して (|python-current|)
	- vim.tabpagesのインデックス化から (|python-tabpages|)

このオブジェクトを使ってタブページウィンドウにアクセスすることができます。これ
らはメソッドを持たず、シーケンスも他のインターフェイスもありません。

タブページの属性:
	number		|tabpagenr()| が返すようなタブページ番号。
	windows		|python-windows| と同様だが、現在のタブページ用。
	vars		タブページの |t:| 変数。
	window		現在のタブページウィンドウ。
	valid		True または False。タブページオブジェクトは、関連する
			タブページがクローズされると無効になる。

タブページオブジェクトの型は vim モジュールの "TabPage" 属性で取得できます。

==============================================================================
Vim 関数 pyeval() と py3eval()				*python-pyeval*

双方向インターフェイスを容易にするため、 |pyeval()| 関数と |py3eval()| 関数を
使って Python の式を評価して、その値を Vim script に渡すことができます。
|pyxeval()| も使用可能です。

==============================================================================
Python 3						*python3*

Python 3 は Nvim でサポートされている唯一のバージョンのため、現時点では
"python" は "python3" と同義です。ただし、Vim や Nvim の古いバージョンをサポー
トすることを目的としたコードにおいて Python 3 が必要な場合は明示的に"python3"
のバリアントを使用することをお勧めします。

							*:py3* *:python3*
:[range]py3 {stmt}
:[range]py3 << [trim] [{endmarker}]
{script}
{endmarker}

:[range]python3 {stmt}
:[range]python3 << [trim] [{endmarker}]
{script}
{endmarker}
	`:py3` コマンドと `:python3` コマンドは `:python` と同様に機能します。
	`:py3` コマンドが機能するか簡単にチェックするには: >vim
		:py3 print("Hello")
<
	使っている Python のバージョンを見るには: >vim
		:py3 import sys
		:py3 print(sys.version)
<							*:py3file*
:[range]py3f[ile] {file}
	`:py3file` コマンドは `:pyfile` と同様に機能します。
							*:py3do*
:[range]py3do {body}
	`:py3do` コマンドは `:pydo` と同様に機能します。

							*E880*
Python 内で SystemExit 例外を発生させても Vim は終了しません。次のようにします:
>vim
>vim
	:py vim.command("qall!")
<
							*has-python*
Python が利用可能かは次のコマンドで確認できます: >vim
	if has('pythonx')
	  echo 'there is Python'
	endif
	if has('python3')
	  echo 'there is Python 3.x'
	endif

Python 2 はサポートされていません。後方互換性を保つため、 `has('python')`は常に
ゼロを返します。

==============================================================================
Python X						*python_x* *pythonx*

"pythonx" および "pyx" プレフィックスは Python 2.6 以降および Python 3 両方で
動作する Python コード用のために導入されました。Nvim は Python 3 のみをサポー
トしているためこれらのコマンドはすべて "python3" と同義となります。

							*:pyx* *:pythonx*
`:pyx` および `:pythonx` は `:python3` と同じ様に機能します。 `:pyx` が機能す
るか確認するには: >vim
	:pyx print("Hello")

使っている Python のバージョンを見るには: >vim
	:pyx import sys
	:pyx print(sys.version)
<
					*:pyxfile* *python_x-special-comments*
`:pyxfile` は `:py3file` と同じ様に機能します。

							*:pyxdo*
`:pyxdo` は `:py3do` と同じ様に機能します。

							*has-pythonx*
`pyx*` 関数とコマンドが機能するか確認するには: >vim
	if has('pythonx')
	  echo 'pyx* commands are available. (Python ' .. &pyx .. ')'
	endif
<

 vim:tw=78:ts=8:noet:ft=help:norl:
